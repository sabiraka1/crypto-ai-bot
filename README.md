crypto-ai-bot
Описание

crypto-ai-bot – это продакшн-готовый бот для автоматической торговли криптовалютами (спотовая торговля, только long) на бирже Gate.io через библиотеку CCXT. Бот поддерживает идентичную логику как для бумажной торговли (paper mode), так и для реальной (live mode), что обеспечивает удобство тестирования стратегий в безопасном режиме
GitHub
. Основной торговый цикл включает этапы: стратегии → фильтр режима рынка → проверка рисков/лимитов → исполнение сделки → защитные выходы → сверка → наблюдение (watchdog) → доведение частичных исполнений
GitHub
. Ниже перечислены ключевые особенности и принципы проекта:

Чистая архитектура: код организован по принципам Clean Architecture с четким разделением на слои app, core (application → domain → infrastructure) и utils. Каждый слой имеет строгие границы и ограничения на зависимости (контролируется static analysis)
GitHub
. Это упрощает поддержку и расширение системы.

Безопасность по умолчанию: встроены механизмы защиты: идемпотентность при размещении ордеров, многоуровневые лимиты риска (на сделку, по времени, суточные), защитные стоп-ордера, Dead Man’s Switch и блокировка запуска нескольких экземпляров (InstanceLock), а также ограничение частоты запросов к брокеру (throttle)
GitHub
.

Наблюдаемость: бот экспонирует метрики для Prometheus, имеет HTTP эндпоинты health и ready для мониторинга состояния, интегрирован с Alertmanager (алерты пересылаются в Telegram)
GitHub
. Также имеется Telegram-бот для управления и получения уведомлений.

Восстановление и надежность: реализована сверка состояния с биржей и обработка частично выполненных ордеров (settlement) с сохранением результатов в базе данных – это обеспечивает корректный учет позиций при сбоях или перезапусках
GitHub
. Все критичные операции стараются быть атомарными и повторяемыми (например, за счет идемпотентных идентификаторов ордеров).

Эти особенности делают бот модульным, безопасным и готовым к работе в продакшене.

Архитектура

Архитектура проекта следует шаблону Clean Architecture (Гекслогональная/Onion архитектура) с разделением на слои, каждый из которых отвечает за свою задачу и ограничен в зависимостях
GitHub
GitHub
. Основные уровни и правила взаимодействия между ними следующие:

app/ – уровень приложения: содержит внешние интерфейсы и точки входа: HTTP API (FastAPI), интеграцию с Telegram (бот и публикация уведомлений), а также настройку зависимостей (файл compose.py) и запуск сервера. Этот слой может зависеть от core.application, core.infrastructure и utils, но не от внутренних деталей домена
GitHub
. Например, здесь определяется FastAPI сервер и маршруты, создаются экземпляры orchestrator’ов и подключаются адаптеры. Compose–модуль выполняет внедрение зависимостей (composition root), связывая интерфейсы (ports) с конкретными реализациями (например, каким брокером или хранилищем пользоваться)
GitHub
.

core/application/ – прикладной уровень логики: реализует бизнес-процессы и кейсы использования. Здесь находятся: оркестратор – главный координатор торгового цикла, use-cases (сценарии) – например, исполнение сделки (execute_trade.py, единственная точка размещения ордеров
GitHub
), обработка частичных исполнений (partial_fills.py), логика защитных стопов (protective_exits.py), модуль reconciliation для сверки балансов/позиций, мониторинг здоровья (health_checker.py), а также файл events_topics.py с константами событий. Слой core.application может зависеть от core.domain и utils, но не от app или core.infrastructure
GitHub
. Благодаря этому бизнес-логика не привязана к внешним технологиям. Контракт взаимодействия между application и инфраструктурой задан через абстракции в ports.py – здесь описаны интерфейсы Port для брокера, шины событий, хранилища и других сервисов
GitHub
. Правило единственной ответственности соблюдается: например, модуль orchestrator.py координирует работу всех компонентов, а модуль execute_trade.py отвечает за единое размещение ордеров (через него проходят все сделки)
GitHub
, что упрощает поддержку идемпотентности и логирование.

core/domain/ – доменный уровень: содержит чистые бизнес-правила, не зависимые от внешних деталей. Здесь реализованы торговые стратегии (strategies/*), логика формирования сигналов (signals/*, включая анализ на нескольких таймфреймах и интеграцию AI-модели), модуль оценки рыночного режима (macro/regime_detector.py), а также менеджер рисков (risk/manager.py) с набором правил риск-менеджмента (risk/rules/*). Слой domain может зависеть только от утилит utils (например, для вычислений), и не зависит от слоёв application, infrastructure или app
GitHub
. Все взаимодействие наружу происходит через возврат значений или вызовы портов, что позволяет легко тестировать доменную логику в изоляции. Например, RiskManager агрегирует все проверки рисков и возвращает решение (ok/не ok и причина), не вызывая внешних систем напрямую
GitHub
GitHub
. Правила риска инкапсулированы в отдельных классах (LossStreakRule, MaxDrawdownRule, CooldownRule и др.) и подключаются к менеджеру рисков
GitHub
. Стратегии и сигналы формируют торговые идеи на основе рыночных данных; они могут комбинироваться через взвешивание и голосование (см. Стратегия торговли ниже). Доменные модели максимально простые (например, баланс брокера передается как обычный dict с полями free_base и free_quote
GitHub
, без сложных DTO-объектов).

core/infrastructure/ – инфраструктурный уровень: содержит реализации портов для внешних сервисов и хранилищ. Этот слой может зависеть от utils, но не от слоёв app, core.application или core.domain
GitHub
. Здесь находятся адаптеры брокера (brokers/*) – например, подключение CCXT (класс CcxtAdapter) и имитация биржи для paper-трейдинга (PaperBroker)
GitHub
; реализация шины событий (events/*) как in-memory EventBus или Redis-брокер сообщений
GitHub
; хранилище данных (storage/*) на SQLite с миграциями и бэкапами
GitHub
; компоненты безопасности (safety/*) – Dead Man’s Switch для экстренной продажи при зависании бота и InstanceLock для предотвращения одновременного запуска второго экземпляра
GitHub
; модуль конфигурации Settings (settings.py + settings_schema.py), отвечающий за загрузку и валидацию переменных окружения. Единым источником конфигурации выступает именно core/infrastructure/settings.py – все настройки читаются только через него
GitHub
 (в том числе поддержка секрета через файлы и base64). Это гарантирует централизованную обработку параметров (с помощью Pydantic-схемы) и применение инвариантов настроек (например, проверка что веса таймфреймов суммируются в 1.0). Инфраструктурный слой отделён от бизнес-логики: например, реализация BrokerPort может быть заменена (на другого брокера) без изменений в core.application, а хранилище можно переключить с SQLite на другую СУБД, реализовав тот же интерфейс.

utils/ – утилиты: вспомогательные функции и классы, используемые во всех слоях. Здесь реализованы: расширения для Decimal и расчёта PnL, логирование и трассировка (присвоение корреляционных ID для цепочек событий), метрики и счётчики, HTTP-клиент, функции ретраев, работа с датами/временем и т.д.
GitHub
. Утилиты не зависят от остальных модулей проекта и могут рассматриваться как отдельная небольшая библиотека общих компонентов.

Правила зависимостей слоёв строго контролируются: в репозитории настроен инструмент Import Linter (конфиг importlinter.ini), и при сборке/CI он гарантирует отсутствие недопустимых импортов (CI сборка упадёт, если, например, core.domain импортирует что-то из core.infrastructure)
GitHub
GitHub
. Это автоматически поддерживает чистоту архитектуры.

Событийные константы: любые события, публикуемые на EventBus, определены единожды в core/application/events_topics.py и используются по именам-константам
GitHub
GitHub
. Никаких "магических строк" в коде для названий событий – благодаря этому подписчики и издатели событий согласованы между собой и легко искать использование событий по имени.

Инварианты дизайна: Некоторые правила заложены в коде и проверяются при запуске (валидация настроек): например, сумма весов таймфреймов Multi-Timeframe = 1.0, сумма весов Fusion (технич. vs AI) = 1.0, лимиты риска не должны быть отрицательными и заданы в разумных пределах и т.д.
GitHub
. Менеджер рисков не выполняет побочных действий (не логирует сам и не публикует события) – только возвращает результат проверки; публикация событий вроде risk.blocked или budget.exceeded происходит на уровне orchestrator’a при получении отказа от RiskManager
GitHub
. Использование InstanceLock гарантирует, что параллельно запущен только один экземпляр бота: лок-файл/флаг захватывается при старте приложения и освобождается при корректном завершении, предотвращая одновременную работу двух процессов
GitHub
.

Таким образом, архитектура сочетает строгие границы ответственности слоёв с практическими мерами по надежности и наблюдаемости, что облегчает развитие проекта командой и эксплуатацию в продакшене.

Структура файлов

Ниже приведена актуальная структура файлов и модулей проекта после финального рефакторинга
GitHub
. (Примечание: папка ops/prometheus/ с конфигурацией мониторинга удалена из этого репозитория – мониторинг вынесен во внешний сервис, см. раздел Мониторинг.) Основные компоненты и их назначение упомянуты в комментариях:

crypto-ai-bot/
├─ README.md
├─ pyproject.toml
├─ requirements.txt
├─ Makefile
├─ Procfile                      # Процессы для деплоя (web и worker)
├─ importlinter.ini             # Правила контроля импортов (слои)
├─ scripts/
│  ├─ backup_db.py
│  ├─ rotate_backups.py
│  ├─ integrity_check.py
│  ├─ run_server.sh
│  └─ run_server.ps1
└─ src/crypto_ai_bot/
   ├─ app/                       # Внешние интерфейсы и запуск
   │  ├─ server.py               # 🌐 FastAPI сервер (эндпоинты health/metrics/pnl/orchestrator/webhook)
   │  ├─ compose.py              # 🔌 DI-композиция зависимостей (broker, storage, bus, health, lock, orchestrators)
   │  ├─ logging_bootstrap.py    # 🧾 Инициализация структурированного логирования
   │  ├─ http_dxy.py             # 🌍 HTTP-источник DXY (индекс доллара, изменение %)
   │  ├─ http_btc_dominance.py   # 🌍 HTTP-источник BTC Dominance (изменение %)
   │  ├─ http_fomc.py            # 🌍 HTTP-источник FOMC (расписание заседаний)
   │  ├─ telegram.py             # 📣 Telegram publisher (отправка исходящих алертов)
   │  ├─ telegram_bot.py         # 🤖 Telegram bot (прием входящих команд /status, /pause, /resume и др.)
   │  └─ telegram_alerts.py      # 🔔 Подписчик Alertmanager (webhook) -> EventBus -> Telegram (алерты)
   ├─ cli/                       # CLI-утилиты (запуск через `cab-*`)
   │  ├─ smoke.py                # Быстрый smoke-тест (простейший прогон цикла)
   │  ├─ maintenance.py          # Обслуживание БД (бэкап, ротация, vacuum, проверка целостности)
   │  ├─ reconcile.py            # Сверка балансов/позиций с биржей
   │  ├─ performance.py          # Отчет по сделкам и PnL (FIFO) за период
   │  └─ health_monitor.py       # Мониторинг /health (может запускаться как отдельный процесс-демон)
   ├─ core/
   │  ├─ application/            # Прикладная логика и координация
   │  │  ├─ orchestrator.py      # Оркестратор – главный цикл оценки сигналов и торговли
   │  │  ├─ ports.py             # Интерфейсы портов (Broker, EventBus, Storage, Safety и др.)
   │  │  ├─ events_topics.py     # Реестр событий (константы тем для EventBus)
   │  │  ├─ protective_exits.py  # Логика защитных выходов (hard stop-loss, trailing stops)
   │  │  ├─ use_cases/
   │  │  │  ├─ eval_and_execute.py
   │  │  │  ├─ execute_trade.py   # ★ Единственная точка исполнения ордеров (идемпотентная)
   │  │  │  └─ partial_fills.py   # Settlement: обработка частично выполненных ордеров
   │  │  ├─ reconciliation/
   │  │  │  ├─ orders.py         # Сверка открытых ордеров между биржей и БД
   │  │  │  ├─ positions.py      # Сверка текущих позиций
   │  │  │  └─ balances.py       # Сверка балансов
   │  │  ├─ regime/
   │  │  │  └─ gated_broker.py   # Обёртка BrokerPort с учетом режима risk_on/off
   │  │  └─ monitoring/
   │  │     └─ health_checker.py # Watchdog: периодические проверки здоровья (БД, шина, DMS)
   │  ├─ domain/                 # Доменная (бизнес) логика
   │  │  ├─ risk/
   │  │  │  ├─ manager.py        # Менеджер риска (агрегирует все правила)
   │  │  │  └─ rules/            # Правила риск-менеджмента:
   │  │  │     ├─ loss_streak.py     # Лимит на серию убытков
   │  │  │     ├─ max_drawdown.py    # Лимит просадки баланса/PNL
   │  │  │     ├─ max_orders_5m.py   # Лимит частоты ордеров (5 мин)
   │  │  │     ├─ max_turnover_5m.py # Лимит оборота (5 мин)
   │  │  │     ├─ cooldown.py        # Лимит частоты сделок (минимальный интервал)
   │  │  │     ├─ daily_loss.py      # Дневной лимит убытка
   │  │  │     ├─ spread_cap.py      # Ограничение на максимальный спред
   │  │  │     └─ correlation_manager.py # Управление корреляциями активов (anti-correlation)
   │  │  ├─ strategies/ ...      # Реализации торговых стратегий (EMA, RSI, Bollinger, ATR и др.)
   │  │  ├─ signals/
   │  │  │  ├─ timeframes.py     # Анализ на нескольких таймфреймах (MTF)
   │  │  │  ├─ fusion.py         # Слияние сигналов (технический + AI)
   │  │  │  ├─ ai_model.py       # Обертка для AI-модели (если используется)
   │  │  │  ├─ ai_scoring.py     # Логика скоринга AI-модели
   │  │  │  └─ feature_pipeline.py # Генерация фичей для AI-модели
   │  │  └─ macro/
   │  │     ├─ regime_detector.py # Определение режима рынка (risk-on/off на основе макро)
   │  │     └─ types.py          # Общие типы для macro-аналитики
   │  └─ infrastructure/         # Инфраструктурные реализации портов
   │     ├─ settings.py          # Загрузка конфигурации из ENV (схема настроек)
   │     ├─ settings_schema.py   # Схемы/инварианты для Settings (Pydantic)
   │     ├─ brokers/
   │     │  ├─ base.py           # Базовый класс BrokerPort
   │     │  ├─ factory.py        # Фабрика для выбора live/paper брокера
   │     │  ├─ ccxt_adapter.py   # Адаптер CCXT (реальная биржа Gate.io)
   │     │  ├─ live.py           # Класс LiveBroker (обёртка CCXTAdapter)
   │     │  └─ paper.py          # Класс PaperBroker (симуляция биржи для paper-трейда)
   │     ├─ events/
   │     │  ├─ bus.py            # AsyncEventBus (шина событий в памяти)
   │     │  ├─ bus_adapter.py    # UnifiedEventBus (выбирает реализацию в зависимости от URL)
   │     │  └─ redis_bus.py      # RedisEventBus (шина на основе Redis PubSub)
   │     ├─ safety/
   │     │  ├─ dead_mans_switch.py # Dead Man's Switch (распродажа при зависании бота)
   │     │  └─ instance_lock.py    # InstanceLock (блокировка повторного запуска)
   │     ├─ storage/
   │     │  ├─ facade.py         # Фасад для операций с БД (реализация StoragePort)
   │     │  ├─ sqlite_adapter.py # Адаптер SQLite (физическое хранение данных)
   │     │  ├─ backup.py         # Утилиты бэкапа базы данных
   │     │  └─ migrations/       # Миграции схемы БД (Alembic-style SQL)
   │     │     ├─ runner.py          # Движок применения миграций
   │     │     ├─ V0001__init.sql    # Начальная схема
   │     │     ├─ V0006__trades_indexes.sql
   │     │     ├─ V0007__idempotency_unique_and_ts.sql
   │     │     ├─ V0008__positions_idx.sql
   │     │     ├─ V0009__trades_unique_ids.sql
   │     │     ├─ V0010__audit_ts_idx.sql
   │     │     └─ V0012__orders_table.sql
   └─ utils/                     # Утилиты (общие вспомогательные модули)
       ├─ decimal.py             # Decimal-настройки и функции (безопасные операции с деньгами)
       ├─ pnl.py                 # Расчет прибыли/убытка (FIFO, учёт комиссий)
       ├─ metrics.py             # Метрики Prometheus (инициализация счётчиков, гистограмм)
       ├─ logging.py             # Настройка логирования, TRACE_ID, контекстный логгер
       ├─ retry.py               # Декораторы/функции повторных попыток (с экспоненциальной задержкой)
       ├─ http_client.py         # Обёртка над httpx для HTTP-запросов (с таймаутами)
       ├─ symbols.py             # Нормализация символов/пар, утилиты по инструментам
       ├─ time.py                # Работа с датой/временем (UTC сейчас, парсинг и пр.)
       └─ trace.py               # Трассировка (проставление корреляционных идентификаторов)


Примечание: Ранее в проекте существовал модуль place_order.py в качестве промежуточного слоя для размещения ордеров, однако после рефакторинга вся логика исполнения сделок сосредоточена в execute_trade.py. Файл place_order.py более не используется и может быть удалён (при условии отсутствия к нему внешних импортов)
GitHub
.

Модули и Слои

Рассмотрим подробнее ключевые компоненты системы и их роли в соответствии с уровнями архитектуры:

App (уровень интерфейсов): Главная задача – инициализация и интеграция. Модуль server.py запускает FastAPI приложение, определяет маршруты HTTP (эндпоинты /health, /ready, /metrics, /orchestrator/*, /pnl/*, а также webhook /alertmanager/webhook для приёма алертов)
GitHub
. Через compose.py происходит сборка (composition root): создаётся конфигурация бота и его зависимостей – например, выбор брокера (live или paper) через фабрику, подключение к хранилищу SQLite, запуск шины событий (Redis или in-memory), создание orchestrator’ов для указанных торговых пар и др.
GitHub
. Также, в app-слое реализована интеграция с Telegram: telegram.py выступает как publisher для отправки уведомлений (через Telegram API) с поддержкой повторов при ошибках, форматирования сообщений в HTML и дедупликации (anti-storm)
GitHub
; telegram_bot.py – Telegram-бот оператор, принимающий команды от пользователей (с проверкой whitelist и ролей) и делегирующий выполнение соответствующих действий (старт/стоп оркестратора, запрос статуса и т.п.)
GitHub
; telegram_alerts.py – подписчик на EventBus, который получает события алертов (например, от Alertmanager) и пересылает их в Telegram канал/чат
GitHub
. Таким образом, app-слой обеспечивает все точки взаимодействия внешнего мира с ботом, без содержащихся внутри бизнес-решений.

Core.Application (бизнес-оркестрация): Содержит высокоуровневую логику работы бота. Orchestrator (orchestrator.py) – центральный компонент, который оркеструет торговый цикл для каждого актива: он циклично (или по событию) запускает оценку сигналов стратегий, применяет фильтр режима рынка, проверяет ограничения RiskManager’ом и затем принимает решение об открытии или закрытии позиции через execute_trade. Оркестратор также реагирует на внешние команды управления (пауза/резюме/стоп) и следит за текущим состоянием торговли (например, автоматически приостанавливает торговлю при срабатывании определённых условий)
GitHub
. Use-case модули реализуют отдельные шаги процесса: в execute_trade.py инкапсулировано непосредственное размещение ордера через брокерский порт – это единственная точка входа для исполнения сделки в системе
GitHub
. Внутри него генерируется уникальный идентификатор ордера (client_order_id) и проверяется идемпотентность (через специальный репозиторий, гарантирующий что один и тот же ордер не разместится повторно)
GitHub
. Также execute_trade выполняет финальные проверки бюджета и лимитов (на всякий случай) и записывает информацию о новом ордере/сделке в хранилище, публикует событие о выполненной или отклонённой сделке. В eval_and_execute.py может быть реализована связка “оценить сигнал и сразу исполнить” для упрощения, а partial_fills.py отвечает за доведение частично выполненных ордеров (settlement): периодически проверяет открытые ордера, обновляет их статус (частично исполнен/исполнен полностью/отменён) и генерирует догоняющие сделки при необходимости
GitHub
. Модуль ProtectiveExits (protective_exits.py) управляет установкой защитных стоп-ордеров: сразу после исполнения основной сделки рассчитывает и выставляет hard stop-loss и/или trailing stop по заданной политике, чтобы ограничить потенциальный убыток или зафиксировать прибыль
GitHub
. Подмодуль Reconciliation (reconciliation/orders.py, balances.py, positions.py) выполняет периодическую сверку ордеров, балансов и позиций между нашей учётной системой (БД) и фактическими данными с биржи, выявляя расхождения и публикуя события об этом (например, reconciliation.position_mismatch) для последующей обработки
GitHub
. Модуль HealthChecker (monitoring/health_checker.py) – своего рода watchdog: следит за "здоровьем" приложения (доступность базы, скорость ответа брокера, активность orchestrator’а), а также интегрирует Dead Man’s Switch (если бот завис и перестал отправлять heartbeat, DMS начнёт аварийное закрытие позиций)
GitHub
. Все выявленные проблемы или изменения здоровья публикуются как события (health.report, safety.dms.triggered и т.д.), на которые, в частности, подписан Telegram-алертинг. Отдельно стоит упомянуть GatedBroker (regime/gated_broker.py) – это обёртка над BrokerPort, которая применяется, если включён режим фильтрации по рынку. Она перехватывает попытки открыть новую позицию, и если текущие макро-условия оцениваются как неблагоприятные (risk-off), то оркестратор получит отказ в исполнении сделки (вместо реального вызова API биржи) либо уменьшит объём позиции
GitHub
. Таким образом реализуется режимный фильтр: когда, к примеру, индекс доллара (DXY) резко растёт или впереди заседание FOMC, бот может автоматически снизить торговую активность.

Core.Domain (доменные модели и правила): Здесь сосредоточены основные алгоритмы принятия решений. Trading Strategies (пакет strategies) реализуют различные торговые подходы, например: пересечение скользящих средних (EMA cross), стратегия на основе ATR, RSI-моментум, Bollinger Bands, а также композиционная стратегия signals_policy (может объединять несколько сигналов и политик) – полный список и параметры стратегий настраиваются через ENV (см. переменная STRATEGY_SET и связанные)
GitHub
. Как правило, каждая стратегия анализирует поступающие рыночные данные (котировки, объёмы) на своём временном интервале и генерирует сигнал: купить, продать или воздержаться. Signals (пакет signals) – связующее звено, которое превращает данные рынка в унифицированные сигналы для стратегий. Например, модуль timeframes.py выполняет Multi-Timeframe анализ – агрегирует сигналы с разных таймфреймов, используя фиксированные веса (по умолчанию: 15m 40%, 1h 25%, 4h 20%, 1d 10%, 1w 5%
GitHub
). Модуль fusion.py может объединять два типа сигналов – технический и от AI-модели – также по заданным весам (например, 65% технический, 35% AI)
GitHub
. Эти подходы повышают надежность сигналов, сглаживая шум на отдельных интервалах. Risk Management (пакет risk) – критически важный компонент: RiskManager (risk/manager.py) агрегирует все правила риск-лимитов и решает, можно ли в текущий момент выполнять новую сделку. Он реализован по принципу "одних ворот": orchestrator перед исполнением сделки всегда вызывает RiskManager.check(...) и получает либо разрешение, либо запрет с указанием причины
GitHub
. Внутри RiskManager последовательно проверяются все правила из пакета risk/rules – каждое правило инкапсулирует отдельное ограничение. Например, LossStreakRule не позволит открыть новую сделку, если подряд уже было N убыточных сделок; MaxDrawdownRule проконтролирует, чтобы просадка баланса/PNL не превысила заданный предел; CooldownRule потребует паузу не менее X секунд между сделками; MaxOrders5mRule и MaxTurnover5mRule ограничивают интенсивность торговли (не более M ордеров или Q объёма за 5 минут), DailyLossRule – остановит торговлю при достижении дневного лимита убытков, SpreadCapRule – запретит вход в позицию, если спред между ценами покупки/продажи слишком велик, а CorrelationManager следит, чтобы бот не держал одновременно позиции по сильно коррелированным инструментам
GitHub
. Все пороговые значения этих правил настраиваются через переменные окружения (см. раздел Переменные окружения ниже). RiskManager возвращает tuple (ok, reason) и не занимается ни логированием, ни посылкой событий – этим занимается orchestrator, получив ответ. Таким образом, доменный уровень реализует логику принятия решений: стратегии → сигнал(ы) → решение о сделке, с обязательным прохождением через фильтр риск-менеджмента.

Core.Infrastructure (инфраструктура и адаптеры): Этот уровень служит мостом между нашим кодом и внешними системами. Реализации BrokerPort находятся в infrastructure/brokers: это адаптеры к реальной бирже и к режиму эмуляции. CcxtAdapter инкапсулирует вызовы библиотеке CCXT (которая поддерживает множество бирж, здесь сконфигурирована для Gate.io) и приводит их к унифицированному интерфейсу (методы fetch_ticker, create_market_buy_quote, create_market_sell_base и др.)
GitHub
. Над ним построены классы LiveBroker (для реальной торговли, использует CCXTAdapter + учитывает комиссии/ограничения биржи) и PaperBroker (для бумажной торговли – может использовать либо sandbox API, либо упрощённую модель исполнения ордеров без реальных запросов)
GitHub
. Выбор реализации брокера происходит в runtime через factory.py на основе переменной MODE (paper или live). EventBusPort реализован двумя способами: встроенная asynchronous шина (просто держит подписчиков в памяти и распространяет события асинхронно) – bus.py, и адаптер для Redis Pub/Sub – redis_bus.py (позволяет масштабировать бота на несколько процессов/узлов)
GitHub
. В коде orchestrator работает с unified EventBus (компонент bus_adapter.py выбирает Redis или InMemory в зависимости от переменной EVENT_BUS_URL) – если URL Redis не указан, используется режим по умолчанию (в памяти). StoragePort представлен в виде фасада (storage/facade.py), который инкапсулирует операции с базой данных SQLite: хранение сделок, ордеров, позиций, балансов, а также таблиц идемпотентности и аудита. Физическая реализация – sqlite_adapter.py – работает с файлом SQLite через библиотеку APSW (или стандартный sqlite3) и применяет миграции схемы при запуске
GitHub
. Миграции хранятся как SQL-файлы в storage/migrations и могут выполняться скриптом migrations/runner.py. База настроена в WAL-режиме для безопасного параллельного доступа. В директории scripts/ предоставлены утилиты для резервного копирования БД и её ротации, которые можно вызывать по расписанию. Компоненты безопасности: safety/dead_mans_switch.py – реализует «рубильник» (DMS), который при длительном отсутствии признаков жизни бота (например, orchestrator не выполнял цикл больше N секунд или не было сообщений health) пытается автоматически закрыть открытую позицию, предполагая, что приложение зависло или потеряло связь. safety/instance_lock.py обеспечивает межпроцессный/межсерверный лок – например, может создавать файл-лок или записывать метку в Redis, что бот уже запущен; при запуске второго экземпляра в том же окружении InstanceLock не даст ему стартовать, тем самым предотвращая состояние гонки или двойную торговлю одним счётом
GitHub
. Settings (settings.py и settings_schema.py) – важнейший модуль конфигурации. При старте приложения он загружает все переменные окружения (.env) и секреты, производит их валидацию (посредством Pydantic-моделей в settings_schema.py) и предоставляет другим частям программы типизированный объект настроек
GitHub
. Например, там проверяется, что суммы весов в настройках MTF и Fusion равны 1.0, что критические лимиты риска не отрицательные, и т.п. Все компоненты infrastructure связаны тем, что они реализуют контракты, определённые в core.application (в ports.py). Таким образом, core.application обращается не к конкретной БД или брокеру, а к абстрактному StoragePort, BrokerPort, EventBusPort – а infrastructure предоставляет им реализацию. Этот подход облегчает тестирование (можно подменить, например, BrokerPort на мок) и будущее расширение (новые биржи, другие базы данных и т.д.)
GitHub
.

Utils (утилиты): Содержит общие вспомогательные функции и классы, не привязанные к бизнес-логике. Здесь реализовано: расширение типа Decimal (функция dec() для создания Decimal с нужным контекстом) и константы для точности, в utils.decimal; модуль utils.pnl для расчёта PnL с учётом комиссии (реализует FIFO-учёт сделок, удобен для генерации отчётов по прибыльности); utils.metrics – инициализация и обновление метрик Prometheus (гистограммы задержек циклов, счётчики событий, бизнес-метрики вроде количества блокировок RiskManager’ом)
GitHub
; utils.logging – настройка структурированного логирования (формат JSON или прочий, Trace ID, уровни логов и др.); utils.retry – содержит декораторы и функции для повторных попыток (с экспоненциальной паузой) при неудачных операциях, используется, например, при публикации событий и в HTTP запросах к внешним API; utils.http_client – обёртка над httpx с заданными таймаутами и perhaps ретраями для HTTP источников (например, для макро-данных DXY/BTC.Dominance); utils.symbols – функции нормализации и парсинга названий торговых пар (разделение на base/quote, приведение к верхнему регистру и т.д.); utils.time – работа со временем (например, utc_now с поддержкой таймзоны, parsing ISO дат); utils.trace – присвоение и логирование trace_id (уникального идентификатора запроса/цикла), который пробрасывается в логи и метрики, помогая прослеживать сквозной поток обработки.

Суммарно, такой разбиение на модули облегчает ориентирование в проекте: новый участник команды может быстро найти нужный участок логики, зная за каким слоем он закреплён (например, любую бизнес-правило – в core/domain, взаимодействие с брокером – в core/infrastructure/brokers, вспомогательную функцию – в utils, и т.д.). Также, благодаря строгим контрактам (ports.py) и единым точкам ответственности (оркестратор, execute_trade, risk_manager, settings), снижается вероятность дублирования кода – каждый аспект реализован один раз в своем месте.

Стратегия торговли

Основной алгоритм работы бота можно представить как конвейер из нескольких этапов, каждый из которых последовательно обрабатывает информацию и принимает решение. Ниже описаны эти этапы в том порядке, в котором они происходят при каждом цикле оркестратора:

**Анализ тренда на старших таймфреймах (Trend Confirmation):
** Бот торгует исключительно на 15-минутном таймфрейме для точных входов и выходов, но перед принятием торгового решения анализирует направление тренда на старших интервалах. Сырые рыночные данные (OHLCV) собираются по таймфреймам: 1 час, 4 часа, 1 день и 1 неделя. Эти старшие таймфреймы используются только для определения общего направления рынка и фильтрации сигналов. Веса для анализа тренда распределены как: 1h = 40%, 4h = 30%, 1d = 20%, 1w = 10%. Такой подход позволяет избежать торговли против основного тренда - если старшие таймфреймы показывают нисходящий тренд, бот не будет открывать длинные позиции даже при наличии сигнала на 15-минутном графике. Результат – фильтр направления, который разрешает или запрещает сделки на основном торговом интервале.

**Генерация торговых сигналов (15-минутный таймфрейм):** Непосредственные торговые сигналы генерируются только на 15-минутном таймфрейме. Именно здесь применяются основные стратегии (EMA cross, RSI, Bollinger Bands и др.) для поиска точек входа. Это обеспечивает своевременную реакцию на рыночные движения и более точные входы в позицию. Сигнал с 15-минутного графика проверяется на соответствие тренду со старших таймфреймов - если направления совпадают, сигнал считается подтвержденным.

**Слияние сигналов (Signal Fusion):** Если в боте задействованы оба типа сигналов – технические (на основе индикаторов с 15м графика) и AI-модель (машинное обучение) – то они объединяются в единый сигнал решения. Слияние происходит по фиксированным долям, например: технический сигнал имеет вес 65%, а сигнал AI – 35%. AI-модель при этом может учитывать данные со всех таймфреймов для более точных предсказаний. Цель – повысить точность входов, комбинируя краткосрочные технические паттерны с AI-анализом GitHub
. Эти проценты заданы как инвариант и изменяются только при обновлении кода (в конфигурации по умолчанию FUSION_W_TECHNICAL=0.65, FUSION_W_AI=0.35). Если AI-компонент не используется, то итоговый сигнал равен чисто техническому. Цель – учесть разные источники сигналов, повысив общую точность принятия решения.

Агрегация стратегий (Strategy Aggregation): Бот поддерживает одновременное использование нескольких торговых стратегий. В настройках можно указать набор стратегий (STRATEGY_SET) и режим их агрегирования (STRATEGY_MODE) – first, vote или weighted
GitHub
. В режиме first бот берёт сигнал первой по списку стратегии (например, более консервативной) и игнорирует остальные приоритетом; в режиме vote решения стратегий (buy/sell/hold) голосуют – выбирается большинство или преобладающее мнение; в режиме weighted каждому сигналу стратегии присвоен вес (задается в STRATEGY_SCORES), и итоговое решение принимается на основе взвешенного суммарного балла. Агрегация стратегий происходит в модуле strategy_manager.py – там реализована логика, которая, исходя из выбранного режима, объединяет несколько сигналов стратегий в один итоговый торговый сигнал
GitHub
. Этот механизм позволяет комбинировать разные подходы (например, трендовые и контртрендовые стратегии) для более устойчивого результата.

Фильтр режима рынка (Regime Filtering): Прежде чем открыть позицию, бот оценивает общий рыночный режим – благоприятен ли сейчас рынок для новых сделок. Используются макро-показатели и события: индекс доллара США (DXY), доминирование биткоина (BTC.D) и календарь заседаний FOMC (ставки ФРС). Специальный компонент RegimeDetector (в core/domain/macro) собирает эти данные (по HTTP API, см. app/http_*.py источники) и определяет флаг risk_on или risk_off. Например, если DXY вырос больше определенного процента за день или ожидается важное событие FOMC в ближайшие часы, может быть выставлен режим risk_off. В случае risk_off стратегия бота меняется: новые входы в рынок блокируются полностью, либо (в режиме weighted) снижается размер позиции (в конфигурации можно задать коэффициент уменьшения объема)
GitHub
GitHub
. Реализация этого находится в core/application/regime/gated_broker.py, который, получив запрос на исполнение сделки, проверяет текущий режим и либо пропускает его к брокеру (если risk_on), либо возвращает отказ/сокращенный ордер (если risk_off)
GitHub
. Таким образом, этот слой выступает защитой от неблагоприятных внешних условий: бот либо сидит в кэше, либо значительно снижает активность, когда высокая волатильность или риски на макро-уровне.

Управление рисками (Risk Management): Если рыночный режим позволяет торговать (risk_on), следующая обязательная стадия – проверка RiskManager’ом. Сюда передается предполагаемая сделка (актив, размер, направление) и текущая информация (история сделок, баланс, открытые позиции из Storage). RiskManager последовательно применяет все правила из пакета core/domain/risk/rules и возвращает результат. Правила охватывают множество аспектов безопасности:

Ограничение серии убыточных сделок (Loss Streak)

Максимальная просадка (Max Drawdown) по балансу или суммарному PnL за период

Ограничение на максимальное количество ордеров за последние 5 минут (MaxOrders5m) и на максимальный совокупный объём за 5 минут (MaxTurnover5m) – предотвращает "залповые" серии ордеров (anti-burst)

Минимальный интервал между ордерами (Cooldown), запрещающий слишком частую торговлю

Ограничение дневного убытка (DailyLoss) – если достигнут лимит потерь за день, дальнейшие сделки блокируются до следующего дня

Ограничение на максимальный спред (SpreadCap) – если разница между лучшим бидом и аском по инструменту больше допустимого %, сделка не разрешается (рынок слишком неликвиден сейчас)

Проверка на корреляцию (Anti-Correlation) – запрет одновременного удержания позиций по сильно коррелирующим инструментам, чтобы снизить суммарный риск портфеля.

Если хотя бы одно правило возвращает "нарушение", RiskManager отклоняет сделку, и orchestrator не будет её выполнять
GitHub
. При этом orchestrator публикует событие о блокировке (risk.blocked или budget.exceeded – в зависимости от причины) и логирует предупреждение с указанием конкретного сработавшего правила. Если все проверки пройдены (ok), процесс продолжается. Таким образом, RiskManager – это центральный пост контроля рисков, предотвращающий нежелательные сделки и обеспечивающий торговлю “в безопасных пределах”.

Исполнение сделки (Trade Execution): Этот этап происходит, если принято решение торговать. Orchestrator формирует запрос на исполнение через use-case execute_trade.py. Здесь выполняются следующие действия: во-первых, генерируется уникальный идентификатор ордера (client_order_id) и проверяется с помощью Idempotency-репозитория, что такой ордер не был уже выполнен ранее (защитa от повторного выполнения в случае сбоев связи или перезапуска приложения)
GitHub
. Во-вторых, производится вызов метода BrokerPort для размещения рыночного ордера – либо buy на фиксированную сумму quote (если хотим открыть/увеличить позицию), либо sell на весь базовый актив позиции (для закрытия позиции). Реализация BrokerPort скрыта за адаптером (например, CCXTAdapter): от execute_trade достаточно вызвать унифицированный метод, не заботясь, paper это или live. После успешного размещения ордера, execute_trade сохраняет информацию о нём в хранилище: добавляет запись в таблицу trades (с деталями сделки, ценой, временем и пр.) и регистрирует открытый ордер в таблице orders (статус "open")
GitHub
. Если брокер сразу возвращает финальный статус (например, ордер полностью исполнен мгновенно как market) – в Storage сразу отразится, что ордер closed и позиция обновлена. Если же ордер исполнен не сразу (например, частично или вообще не по рынку), он останется помеченным как open до дальнейшей обработки. После записи данных, execute_trade публикует соответствующее событие через EventBus: либо trade.completed (успешная сделка), либо trade.failed (если возникла ошибка или отклонение)
GitHub
. В случае ошибки от брокера (например, недостаточно средств, перебор запросов) функция вернет исключение, orchestrator его обработает – в простейшем случае залогирует и продолжит цикл. Важно, что все сделки проходят через эту функцию
GitHub
, что гарантирует единообразие обработки (идемпотентность, запись, события).

Защитные выходы (Protective Exits): Сразу после открытия новой позиции (buy) бот выставляет защитные ордера на случай неблагоприятного движения рынка. Логика реализована в core/application/protective_exits.py: туда передаются детали совершённой сделки (цена входа, объём, выбранная стратегия выхода из настроек). Бывают два типа защитных ордеров:

Hard Stop-Loss: жёсткий стоп-ордер на продажу при определённой цене ниже цены входа (например, -5% от цены входа). Если цена падает до этого уровня, позиция автоматически закрывается, ограничивая убыток.

Trailing Stop: плавающий стоп-лосс, “подтягивающийся” вслед за ценой, если она растёт. Например, устанавливается на расстоянии 3% от текущей цены и обновляется по мере роста цены. Когда цена разворачивается и опускается на 3% от максимума – срабатывает продажа.

ProtectiveExits на основе конфигурации может установить один или оба типа стопов. Для их реализации используются лимитные или рыночные ордера через тот же BrokerPort (но с особым признаком, чтобы отличить от обычных торговых ордеров). Эти ордера также сохраняются в Storage (как ордера со статусом open). Далее orchestrator или отдельный компонент следит за их выполнением: если стоп-ордер исполнился, это приводит к уменьшению/закрытию позиции, и бот публикует событие order.executed (которое может перехватить Telegram-alerts и уведомить команду)
GitHub
. Защитные выходы – критический элемент безопасной торговли: даже если RiskManager разрешил сделку, она может оказаться убыточной, и стоп-лосс ограничивает этот убыток до приемлемого уровня. Trailing-stop позволяет зафиксировать прибыль, если тренд сменился.

Сверка (Reconciliation): Этот фоновый процесс периодически запускается (по таймеру, например раз в несколько минут, настраивается через RECONCILE_INTERVAL_SEC). Цель – убедиться, что наш internal state совпадает с фактическим на бирже. Модули core/application/reconciliation/* по очереди делают запросы через BrokerPort: получить список активных ордеров, текущие балансы и открытые позиции на бирже. Затем сравнивают эти данные с нашим хранилищем (таблицы orders, balances, positions). Если обнаруживается рассинхронизация – например, на бирже ордер уже исполнен/отменён, а в БД ещё числится open, или баланс на счёте отличается (в пределах допуска) – то reconciliation выполнит корректировки. Ордеры, отсутствующие на бирже, помечаются закрытыми и могут быть записаны в trades (если исполнены). Неизвестные новые сделки на бирже (если вдруг такое произошло) могут быть залогированы. Балансы приводятся в соответствие. Каждый акт сверки завершает публикацией события reconciliation.completed (с указанием обнаруженных расхождений, если были)
GitHub
. Это повышает надежность: даже если по каким-то причинам (сеть, сбой) мы пропустили уведомление об изменении, регулярная сверка поправит ситуацию, и бот всегда "знает" реальное состояние счёта.

Watchdog (Мониторинг здоровья): Параллельно с торговым циклом работает “сторожевой пёс” – модуль health_checker.py. Он периодически (интервал настраивается WATCHDOG_INTERVAL_SEC, например каждые 3 секунды) выполняет проверки:

Доступность и время отклика основных компонентов: базы данных (SQLite), брокера (выполняется быстрый запрос, например, получение серверного времени или ping), шины событий (если Redis – проверяется соединение).

Проверяет наличие "heartbeat" – сигналов активности orchestrator’ов. Каждый orchestrator может обновлять отметку времени своего последнего цикла; если она давно не обновлялась – вероятно, цикл завис.

Контролирует, не пора ли активировать Dead Man’s Switch: если флаг DMS включён и heartbeat отсутствует дольше заданного порога, health_checker инициирует публикацию событий safety.dms.triggered и может напрямую вызвать методы DMS для аварийного закрытия позиций
GitHub
.

Проверяет наличие InstanceLock – в норме он должен быть удержан. Если по какой-то причине lock потерян, можно срочно остановить бота.

Результаты этих проверок агрегируются в статус /health (подробный JSON с информацией о состоянии всех подсистем) и /ready (простое OK/FAIL состояние готовности) – эти эндпоинты обслуживает FastAPI в server.py. Watchdog публикует события watchdog.heartbeat (периодический сигнал, что бот жив) и health.report (при обнаружении проблем с указанием, что произошло)
GitHub
. Telegram-алертинг настроен так, что при появлении проблем (например, база недоступна) отправляется сообщение команде. Таким образом, Watchdog обеспечивает мониторинг внутренних метрик работы бота и готов немедленно сигнализировать о сбоях.

Доведение частичных исполнений (Settlement): Если какие-то ордера были исполнены не мгновенно и остались висящими (например, лимитные ордера или частично исполненные рыночные – хотя бот в основном использует рыночные ордера для входа/выхода), за ними нужен присмотр. Компонент partial_fills.py выполняется периодически (по SETTLEMENT_INTERVAL_SEC) и обходит все открытые ордера из Storage
GitHub
. Для каждого такого ордера он запрашивает у брокера обновлённый статус (через BrokerPort.fetch_order). Если ордер уже полностью исполнен на бирже – обновляет в БД статус, вычисляет фактический исполненный объём и цену, добавляет соответствующую сделку в trades (если были дополнительные исполнения), и публикует событие trade.settled. Если ордер всё ещё частично исполнен, но по времени превысил некий таймаут ожидания, либо явно отменён – бот может принять решение “догнать” его остаток: например, если лимитный ордер выполнился только на 70% и долго стоит в книгах, partial_fills может отменить оставшуюся часть и сразу выставить новый рыночный ордер на оставшиеся 30% (это называется partial follow-up). Такой дополнительный ордер получает специальный суффикс client_id (например -pf) и событие trade.partial_followup
GitHub
. В итоге позиция доводится до нужного размера или закрывается полностью. Этот механизм гарантирует, что бот не зависнет, имея “висящие хвосты” ордеров – все начинаемые ордера либо завершаются исполнением, либо закрываются принудительно, сохраняя согласованность состояния.

После прохождения всех этих этапов, цикл может повторяться заново (возвращаясь к сбору новых сигналов). Такая циклическая архитектура обеспечивает полный замкнутый контур автоторговли: от получения данных → до принятия решения → до исполнения и контроля исполнения → до мониторинга системы в целом.

Запуск

Для запуска и использования crypto-ai-bot выполните следующие шаги:

1. Установка окружения:
Создайте виртуальное окружение Python (версия 3.11+) и установите зависимости:

python -m venv .venv
# Активировать виртуальное окружение:
# Windows:
.\.venv\Scripts\Activate.ps1
# Linux / macOS:
source .venv/bin/activate

pip install -U pip wheel
pip install -e .


Примечание: Установка в editable-режиме (-e .) позволит вносить изменения в код и сразу их тестировать без переустановки пакета.

2. Конфигурация:
Скопируйте файл .env.example в .env и задайте в нём необходимые переменные окружения
GitHub
. В примере .env.example указаны безопасные дефолты для режима paper. Минимально необходимо указать: режим (MODE=paper или live), биржу (EXCHANGE=gateio), торговый символ (SYMBOL или несколько через запятую в SYMBOLS), а также учётные данные API (для live-режима). Если вы запускаете live-режим, заполните API_KEY и API_SECRET (или используйте подход с файловыми секретами).

Бот поддерживает несколько способов задать секретные ключи API
GitHub
:

Прямо в переменных API_KEY / API_SECRET (небезопасно хранить в .env в репозитории).

Указать путь к файлу с ключом в переменных API_KEY_FILE / API_SECRET_FILE.

Указать base64-encoded строку ключа в API_KEY_B64 / API_SECRET_B64.

Указать общий JSON-файл через SECRETS_FILE, где хранятся оба ключа.

Приоритет отдается прямым переменным, затем файлам, затем base64, затем JSON-файлу. Выберите удобный и безопасный способ.

3. Запуск API-сервера:
После настройки переменных окружения, вы можете запустить HTTP API, через который осуществляется управление ботом и получение его статуса. Команда запуска через Uvicorn:

uvicorn crypto_ai_bot.app.server:app --host 0.0.0.0 --port 8000


Это запустит FastAPI сервер на указанном порту (в примере 8000)
GitHub
. Можно проверить базовую работоспособность: открыть в браузере http://localhost:8000/health (должен вернуть JSON с состоянием) или http://localhost:8000/docs (интерактивная документация Swagger UI для API).

4. CLI-команды обслуживания:
Библиотека устанавливает ряд утилит командной строки (entry points), начинающихся с префикса cab- (crypto-ai-bot). Эти команды помогают в отладке, обслуживании и мониторинге. Ниже несколько примеров их использования:

cab-smoke – выполнить быстрый smoke-тест: приложение последовательно проверит соединение с брокером, БД, выполнит один цикл получения данных и выйдет. Полезно для проверки, что конфигурация верна и основные компоненты работают
GitHub
.

Команды обслуживания БД (cab-maintenance):

cab-maintenance backup – сделать резервную копию базы данных (файл сохраняется по пути, указанному в логах)
GitHub
.

cab-maintenance rotate --days 30 – удалить старые бэкапы старше 30 дней.

cab-maintenance vacuum – выполнить VACUUM (перестройку) SQLite-файла для уменьшения размера и дефрагментации.

cab-maintenance integrity – проверить целостность базы данных.

cab-maintenance list – вывести список существующих бэкапов.

cab-reconcile – вручную запустить процесс сверки балансов и позиций с биржей
GitHub
. Результаты выводятся в консоль (несовпадения, если есть, также будут залогированы).

cab-health-monitor – одномоментно проверить health-эндпоинт запущенного API. Например: cab-health-monitor --oneshot --url http://127.0.0.1:8000/health произведет одиночный опрос /health и выведет статус
GitHub
. Без флага --oneshot эта утилита может работать как демон, регулярно проверяя здоровье (в продакшене используется как отдельный воркер-процесс, см. Procfile).

cab-perf – сгенерировать отчет по сегодняшним сделкам и PnL
GitHub
. Показывает суммарный реализованный PnL (по FIFO учёту), оборот (сумму всех выполненных ордеров) и количество ордеров за текущий день. Полезно для быстрой оценки результатов торговли.

Все эти команды облегчают эксплуатацию бота и могут использоваться в скриптах или ручном режиме.

5. HTTP API эндпоинты:
При запущенном сервере (п.3) доступны следующие основные HTTP-методы для мониторинга и управления ботом:

GET /health – детальный отчет о состоянии приложения (пинг базы данных, состояние шины событий, соединение с биржей и пр.)
GitHub
. Возвращает JSON с разделами "database", "broker", "event_bus", "orchestrators" и т.д.

GET /ready – индикатор готовности приложения
GitHub
. Возвращает 200 OK если бот функционирует нормально (основные зависимости доступны и нет критических сбоев), либо 503 Service Unavailable если обнаружены проблемы.

GET /metrics – метрики Prometheus в текстовом формате
GitHub
. Содержит метрики процесса, Python runtime, а также кастомные метрики бота (счётчики блокировок RiskManager’ом, время выполнения циклов, количество сделок и т.п.).

GET /orchestrator/status?symbol=<SYM> – получить статус оркестратора для заданного символа
GitHub
. В ответ придет JSON с информацией: запущен ли цикл, время последнего цикла, текущая фаза, причина паузы (если на паузе) и др.

POST /orchestrator/start?symbol=<SYM> – запустить оркестратор (автоторговлю) для указанного символа. Аналогично доступны stop, pause, resume по этому же пути (указать желаемое действие)
GitHub
. Важно: эти методы защищены токеном – требуется передать заголовок Authorization: Bearer <API_TOKEN>, где значение API_TOKEN задается в конфигурации (чтобы предотвратить несанкционированное управление)
GitHub
.

GET /pnl/today?symbol=<SYM> – получить агрегированную статистику по прибыли и убытку за текущие сутки
GitHub
. Возвращает JSON с полями: реализованный PnL в котируемой валюте, суммарный оборот за день, количество ордеров за день по этому символу. Эти значения бот считает на основе данных в хранилище (таблица trades), используя FIFO-алгоритм для учета прибыли.

Помимо перечисленных, имеются и другие эндпоинты (их можно посмотреть через /docs): например, POST /backtest для запуска бэктеста (если реализовано), GET /strategies или GET /signals для просмотра текущих сигналов (опционально). Основные же – это health/ready, orchestrator control и pnl.

6. Telegram-интеграция:
Если в конфигурации включена интеграция с Telegram (переменная TELEGRAM_ENABLED=1 и заданы токен/чат-id), бот предоставляет удобный интерфейс в Telegram для мониторинга и управления. Интеграция разделена на три компонента (см. также App слой выше):

Telegram Publisher (app/telegram.py): отвечает только за отправку сообщений. Он подписан на важные события (например, блокировка риска, завершение сделки, срабатывание DMS) и отправляет уведомления в указанный канал/чат. Включает анти-спам логику: схлопывание дубликатов, ограничение частоты, повтор попытки отправки при ошибке сети
GitHub
.

Telegram Bot (app/telegram_bot.py): отдельный Telegram-бот для управления. Получает команды от пользователей. Чтобы обеспечить безопасность, бот поддерживает whitelist пользователей (переменная TELEGRAM_ALLOWED_USERS) и разные уровни доступа (например, ADMIN может останавливать бот, оператор – только ставить на паузу и смотреть статус). Команды парсятся и выполняются через вызовы соответствующих use-case или orchestrator методов
GitHub
.

Telegram Alerts Subscriber (app/telegram_alerts.py): получает события из EventBus, отфильтровывает алерты (например, события от Alertmanager или внутренние предупреждения) и формирует человекочитаемые сообщения, которые пересылает через publisher в Telegram
GitHub
. Таким образом, оповещения о системных событиях (как то: сработал стоп-лосс, превышен лимит, упал коннект к бирже, пришёл алерт от Prometheus) оперативно доставляются в мессенджер.

Основные команды Telegram-бота, которые реализованы: /status – текущий статус торгов (запущен ли бот, какая позиция по каждому символу, PnL и т.д.), /today – суммарный PnL за день, /pnl – подробная информация по прибыли/убытку, /position – показать размер и цену текущей позиции, /balance – показать баланс на счету, /limits – выдать текущие лимиты риска и их использование, /pause, /resume, /stop – управление торговлей (пауза/возобновление/остановка оркестратора), /health – краткая сводка состояния (аналог /ready)
GitHub
. Команды можно расширять при необходимости.

Если Telegram-настройки не заданы (или TELEGRAM_ENABLED=0), то вся интеграция работает в no-op режиме – бот просто не запускает Telegram-потоки, и это никак не мешает основной логике
GitHub
. Это удобно, т.к. на этапе разработки можно не настраивать Telegram, а в продакшене просто добавить нужные токены и перезапустить бота.

Переменные окружения

Основная конфигурация бота задаётся через переменные окружения (например, в файле .env). Ниже перечислены ключевые переменные по категориям (все значения ожидаются в строковом формате, числовые – тоже как строки, но будут приведены к нужному типу в коде):

Торговля (основные настройки):

MODE – режим работы: paper (бумажный, без реальных ордеров) или live (торговля на реальном аккаунте)
GitHub
. В paper-режиме бот либо использует sandbox API биржи, либо эмулирует выполнение ордеров локально.

EXCHANGE – идентификатор биржи для CCXT (например, gateio, binance, bybit и т.д.)
GitHub
. Проект ориентирован на Gate.io, хотя технически поддержка других бирж через CCXT возможна, если они имеют необходимые маркет-методы.

SYMBOLS – список торговых пар (инструментов), по которым запускать торговые циклы, через запятую
GitHub
. Пример: SYMBOLS=BTC/USDT,ETH/USDT. Для каждой пары будет запущен отдельный orchestrator. Примечание: переменная SYMBOL (без S) тоже может использоваться для указания единственного инструмента.

FIXED_AMOUNT – фиксированная сумма (в котируемой валюте), на которую покупать при открытии позиции
GitHub
. Используется, если выбрана стратегия управления размером позиции fixed. Например, FIXED_AMOUNT=50 означает каждая сделка ~ на $50.

PRICE_FEED – способ получения цены для исполнения ордера. По умолчанию fixed – означает использовать фиксированную цену из FIXED_PRICE (актуально для тестирования на исторических данных или бэктеста). Если указать live, бот будет брать текущую рыночную цену с биржи (через fetch_ticker).

FIXED_PRICE – фиксированная цена для исполнения сделок (в котируемой валюте) при режиме PRICE_FEED=fixed
GitHub
. Игнорируется, если бот работает с реальным рыночным фидом цен.

(Примечание: Более расширенные настройки стратегий, как правило, задаются через отдельные переменные: например, выбор набора стратегий STRATEGY_SET, режим их агрегации STRATEGY_MODE, параметры целевой волатильности, Kelly-фракции и др. – смотрите .env.example для полного списка. Здесь перечислены только основные.)

Multi-Timeframe / Fusion (веса сигналов, инварианты):

MTF_W_M15, MTF_W_H1, MTF_W_H4, MTF_W_D1, MTF_W_W1 – веса для анализа тренда на разных таймфреймах. 
По умолчанию: MTF_W_M15=0.0 (не используется для тренда), MTF_W_H1=0.40, MTF_W_H4=0.30, MTF_W_D1=0.20, MTF_W_W1=0.10 GitHub
. 
Важно: 15-минутный таймфрейм используется только для генерации торговых сигналов (точек входа/выхода), 
а старшие таймфреймы (1ч, 4ч, 1д, 1н) - исключительно для определения направления тренда и фильтрации ложных сигналов.
Веса старших таймфреймов должны суммироваться в 1.0 (это проверяется при запуске) GitHub

.TRADING_TIMEFRAME – основной торговый интервал (по умолчанию "15m"). На этом таймфрейме генерируются все торговые сигналы и происходит исполнение сделок GitHub

.FUSION_W_TECHNICAL, FUSION_W_AI – веса для слияния технического (с 15м графика) и AI-сигнала GitHub

. По умолчанию 0.65 (тех) и 0.35 (AI). Также должны суммироваться в 1.0. Если AI-модель не используется, можно оставить AI=0.0 и TECHNICAL=1.0.

Risk & Safety (лимиты рисков и параметры безопасности):

RISK_COOLDOWN_SEC – минимальный интервал в секундах между двумя последовательными сделками (если предыдущая сделка была менее X секунд назад – новая не откроется)
GitHub
.

RISK_MAX_SPREAD_PCT – максимальный допустимый спред (разница между ask и bid) в процентах от цены, при котором бот всё ещё позволяет ставить рыночный ордер
GitHub
. Если спред на рынке больше этого порога – новые входы запрещены (слишком низкая ликвидность). Пример: 0.5 означает 0.5% от цены.

RISK_MAX_SLIPPAGE_PCT – максимальное проскальзывание (slippage) в процентах
GitHub
. Используется как sanity-check: сравнивает цену исполнения ордера с ценой на момент решения. Если проскальзывание больше заданного, вероятно что-то не так (например, резкая просадка) – такие случаи могут логироваться или учитываться в риск-аналитике.

RISK_DAILY_LOSS_LIMIT_QUOTE – дневной лимит убытка (в котируемой валюте)
GitHub
. Например, 100 означает бот не должен потерять более 100 USDT за день – при достижении этого порога RiskManager начнет блокировать все новые сделки до следующего дня.

RISK_MAX_ORDERS_5M – лимит на количество ордеров за последний 5-минутный интервал
GitHub
. Например, 5 означает не более 5 ордеров за любые текущие 5 минут. 0 означает отключено (без лимита).

RISK_MAX_TURNOVER_5M_QUOTE – лимит на суммарный оборот (quote-сумма всех ордеров) за 5 минут
GitHub
. Например, 1000 означает не более чем на $1000 ордеров за 5 минут. 0 – без ограничения.

SAFETY_MAX_ORDERS_PER_DAY – максимальное число ордеров в сутки
GitHub
. Например, 50 – бот остановится или будет блокировать сделки после размещения 50 ордеров в текущем календарном дне.

SAFETY_MAX_TURNOVER_QUOTE_PER_DAY – максимальный дневной оборот (в котируемой валюте)
GitHub
. Например, 10000 – не торговать более чем на $10k в день суммарно (покупки + продажи). Достигнув лимита, бот переходит в режим только чтения.

(Дополнительно: см. также RISK_MAX_POSITION_BASE – лимит на размер позиции, RISK_MAX_FEE_PCT – максимум приемлемой комиссии, IDEMPOTENCY_TTL_SEC – время жизни идентификатора идемпотентности, и др., которые могут быть заданы при необходимости. В данной сводке приведены самые ключевые параметры.)

Regime (фильтр макро-режима):

REGIME_ENABLED – включить ли режимный фильтр (0 или 1)
GitHub
. Если 0, то бот игнорирует макро-показатели и всегда считает режим risk_on.

REGIME_DXY_URL, REGIME_BTC_DOM_URL, REGIME_FOMC_URL – URL API-источников для показателей DXY, BTC Dominance и календаря FOMC соответственно
GitHub
. По умолчанию могут быть заполнены демо-адреса, либо пусты. Если пусто – соответствующий показатель считается не активным.

REGIME_DXY_LIMIT_PCT – порог изменения DXY (в %), выше которого считается рынок risk_off
GitHub
. Например, 0.35 означает, что рост DXY >0.35% за день – негативный сигнал для крипты.

REGIME_BTC_DOM_LIMIT_PCT – порог изменения доминации BTC (в %) для risk_off
GitHub
. Например, 0.60 – рост доли BTC на рынке >0.6% означает отток капитала из альткоинов (риск).

REGIME_FOMC_BLOCK_HOURS – количество часов до/после события FOMC, в течение которых включается режим risk_off
GitHub
. Например, 8 означает за 8 часов до и после решения по ставке новые сделки блокируются (во избежание волатильности).

(Дополнительно: есть настройки REGIME_BLOCK_BUY, REGIME_WEIGHT_MULT_RISK_OFF – см. .env.example – для тонкой настройки поведения: например, блокировать только покупки (оставляя продажи открытыми для выхода) или уменьшать веса стратегий на X% вместо полного блокирования.)

Telegram (интеграция с мессенджером):

TELEGRAM_ENABLED – флаг включения Telegram-интеграции (0 или 1)
GitHub
. Если 0, весь код, связанный с Telegram, не будет активирован.

TELEGRAM_BOT_TOKEN – токен HTTP API вашего Telegram-бота (получается у @BotFather)
GitHub
.

TELEGRAM_CHAT_ID – ID чата или канала, куда бот будет слать уведомления
GitHub
. Можно указать свой user_id для личных сообщений или id группы/канала.

TELEGRAM_ALERTS_CHAT_ID – (опц.) отдельный чат для алертов (например, Alertmanager). Если не указан, алерты пойдут в основной TELEGRAM_CHAT_ID
GitHub
.

TELEGRAM_BOT_COMMANDS_ENABLED – флаг разрешения команд бота (0/1)
GitHub
. Если 0, бот не будет реагировать на команды от пользователей (но продолжит отправлять алерты, если включен).

TELEGRAM_ALLOWED_USERS – список разрешенных Telegram user_id через запятую
GitHub
. Бот будет реагировать только на команды от этих пользователей. Можно узнать свой user_id с помощью специальных ботов (@userinfobot, например). Рекомендуется указать как минимум своего пользователя здесь, особенно если бот будет в публичной группе, чтобы посторонние не смогли им управлять.

Инфраструктура и прочие:

EVENT_BUS_URL – URL для подключения к внешней шине событий (Redis). Если оставить пустым, бот использует внутреннюю in-memory шину
GitHub
. Формат для Redis: redis://<host>:<port>/<db> – например, redis://localhost:6379/0. На продакшене рекомендуется поднять Redis для масштабирования и сохранности событий.

DB_PATH – путь до файла SQLite базы данных
GitHub
. По умолчанию что-то вроде ./data/trader-<exchange>-<symbol>-<mode>.sqlite3, можно поменять. Если указать :memory:, бот создаст БД в памяти (но тогда данные не сохранятся между запусками).

API_TOKEN – токен для защиты HTTP эндпоинтов управления orchestrator’ом
GitHub
. Задайте любой случайный строковый ключ. Запросы на старт/стоп/паузу торгов должны содержать этот токен (см. выше). Если вы не планируете пользоваться этими эндпоинтами (например, управляете только через Telegram), можно оставить значение по умолчанию, но безопаснее всё равно поставить сложную строку.

API_KEY / API_SECRET – ключ и секрет API биржи (например, ключи Gate.io)
GitHub
. Заполняются только для live-режима. Для paper можно оставить пустыми (эмулятор их не требует). Как упомянуто, можно использовать альтернативные переменные API_KEY_FILE, etc. Вместо явного указания в .env.

BROKER_RATE_RPS / BROKER_RATE_BURST – (опционально) лимиты запросов к API биржи (requests per second и burst). Если не указаны, используются дефолты CCXT либо настройки по умолчанию. Можно выставить, чтобы ограничить частоту запросов ботом (на случай агрессивных настроек, чтобы не попасть под бан биржи).

LOG_LEVEL – уровень логирования (DEBUG, INFO, WARNING, ERROR). По умолчанию INFO.

...и другие переменные (HTTP_TIMEOUT, METRICS_BUCKETS_MS для кастомизации гистограмм, STRATEGY_SET как упоминалось, POSITION_SIZER для выбора алгоритма расчета размера позиции, и т.д.). См. файл .env.example – он содержит подробные комментарии ко всем параметрам конфигурации
GitHub
GitHub
GitHub
.

Важно: Все конфигурационные параметры проходят проверку при запуске. Если какое-то значение не соответствует ожидаемому формату (например, строка вместо числа там, где нужно число; сумма весов не равна 1.0; неизвестное имя стратегии и т.п.), приложение не запустится (выдаст ошибку валидации с описанием проблемы)
GitHub
. Это сделано намеренно, чтобы избежать скрытых ошибок в рантайме из-за неверной конфигурации.

Тестирование

Для проекта настроен набор автоматических тестов и утилит для контроля качества кода. Основные направления тестирования и проверки:

Unit-тесты: В директории tests/ реализованы модульные тесты для ключевых компонентов – правил риск-менеджмента, оркестратора, логики идемпотентности, подсчета PnL, и т.д. Вы можете запускать их с помощью pytest. При установке опций разработки (pip install -e .[dev]) подключаются PyTest, MyPy, Ruff и другие инструменты. Запустить все тесты: pytest -q (ключ -q для краткого вывода). Минимальный порог покрытия кода контролируется (не менее 80%). Примечание: маркировки тестов позволяют выделять медленные (-m "not slow") или интеграционные тесты.

Интеграционные тесты: Некоторые тесты проверяют связку компонентов – например, эмуляцию торговли на PaperBroker с использованием реального CCXT sandbox, или работу RedisEventBus с реальным Redis (при условии доступности). Такие тесты помечены как integration и могут требовать запущенного окружения (Redis, подключение к тестовой бирже). Их можно исключить или настроить перед запуском.

Smoke-тесты: Упомянутая ранее команда cab-smoke является быстрым энд-ту-энд тестом: она поднимает все основные компоненты (брокер в режиме dry-run, orchestrator, event bus, storage в памяти) и пытается пройти через один полный цикл (сгенерировать сигнал, проверить риск, "исполнить" сделку на бумаге и закрыть всё). Это позволяет убедиться, что сборка бота работоспособна как целое. Обычно cab-smoke также запускается в CI на каждом коммите.

Статический анализ кода: В проекте настроены линтеры: Ruff (комбинирует функции flake8, isort, pyflakes и др.) и MyPy (статическая проверка типов). Они конфигурированы в pyproject.toml и CI. Обратите внимание: правила Ruff включают требование использовать структурированные исключения (не допускать bare except и т.п., конфиги ruff: BLE, TRY). Также настроен Import Linter (упоминался ранее) – он проверяет архитектурные зависимости. Чтобы запустить все линтеры и тесты локально, можно использовать pre-commit (файл конфигурации .pre-commit-config.yaml настроен). В CI при каждом Pull Request автоматически выполняются: Ruff, MyPy, PyTest и Import Linter
GitHub
, что предотвращает попадание некачественного кода в main-ветку.

Мониторинг в тестах: Отдельно, тесты мониторинга (если так можно назвать) – это скрипты/команды, которые проверяют, что бот корректно отчитывается о своем состоянии. Например, cab-health-monitor (oneshot) можно включить в планировщик, чтобы он раз в несколько минут опрашивал /health и, в случае проблем, уведомлял команду. Также, Alertmanager (при правильной настройке) будет отправлять тестовый алерт при старте, чтобы убедиться, что связка Alertmanager->EventBus->Telegram работает (его можно отловить в логах или Telegram).

Подводя итог, для локальной проверки рекомендуется запускать хотя бы cab-smoke и несколько ключевых unit-тестов после внесения изменений. В продакшн-конвейере (CI/CD) всё перечисленное автоматизировано, и при возникновении проблемы (не пройден тест или нарушение стиля) сборка отклонится.

Мониторинг

Для мониторинга бота используется внешняя связка Prometheus + Grafana + Alertmanager, вынесенная в отдельный репозиторий crypto-bot-monitoring. В этом репозитории находятся конфигурации и манифесты, необходимые для деплоя системы наблюдения (например, Docker Compose или Terraform для Prometheus и Grafana). Важно: сам бот экспонирует метрики и получает вебхуки алертов, но не разворачивает полноценно всю мониторинговую инфраструктуру – это сделано намеренно, чтобы разделить приложение и инструменты наблюдения (Infrastructure as a Service)
GitHub
.

Что есть внутри бота для мониторинга:

Эндпоинт GET /metrics – метрики Prometheus. Prometheus, запущенный отдельно (например, на Railway или любом сервере), будет периодически опрашивать этот URL. Метрики включают технические показатели (использование CPU, RAM – благодаря Prometheus client для Python) и кастомные метрики бота: время выполнения каждого цикла orchestrator’а, количество выполненных сделок, количество сработавших правил риска, задержки на вызов внешних API, и т.п. Эти метрики объявляются и обновляются в модуле utils.metrics и других местах (например, каждый раз при блокировке сделки RiskManager инкрементирует счётчик risk_blocked_total{rule="..."}). Гистограммы задаются с кастомными buckets (см. METRICS_BUCKETS_MS в конфигурации) для тонкого измерения латентности
GitHub
.

Эндпоинты /health и /ready – позволяют Alertmanager выполнять health-check’и. Например, можно настроить Alertmanager rule: если /ready возвращает 503 более X минут – слать алерт. Или если JSON от /health содержит database.status != "UP", тоже слать алерт. Таким образом, бот предоставляет структуру для гибкого мониторинга своего состояния.

Alertmanager Webhook: В FastAPI настроен маршрут /alertmanager/webhook (в server.py), который принимает POST-запросы от Alertmanager. Alertmanager, настроенный в отдельном сервисе, можно сконфигурировать так, чтобы он отправлял уведомления не напрямую в Telegram/email, а в этот вебхук. Бот, получив webhook (через механизм EventBus), сформирует событие alerts.alertmanager, которое ловит модуль telegram_alerts.py и транслирует в Telegram
GitHub
. Тем самым, алерты из системы мониторинга попадают в общий канал уведомлений, наряду с внутренними сообщениями бота. В TELEGRAM_ALERTS_CHAT_ID можно даже указать отдельную группу для технических алертов, чтобы не смешивать с бизнес-уведомлениями.

Внешняя система мониторинга: В репозитории crypto-bot-monitoring находятся конфигурации Prometheus, Alertmanager и Grafana. Там, например, определяется:

Job для сбора метрик с вашего приложения (scrape target – URL вашего деплоя crypto-ai-bot, /metrics, интервал опроса).

Правила алертинга (Alertmanager rules) – например, триггер на отсутствие данных от бота, на увеличение ошибки RiskManager’а, на заполнение диска (если на Railway, можно мониторить free disk space через метрики), на падение готовности.

Настройки Alertmanager: куда отправлять алерты помимо Telegram (можно настроить дублирование на email, Slack, и т.п.).

Grafana dashboard: дашборд, отображающий основные метрики – PnL за день, количество сделок, использование лимитов, график баланса, время отклика orchestrator’а, и т.д. (Набор графиков можно составить по потребностям команды).

Эта система мониторинга деплоится отдельно – например, на другом сервисе или VM. В нашем случае, на Railway запущен отдельный экземпляр Prometheus/Alertmanager/Grafana, и конфиги для них хранятся в приватном репозитории (упомянутом выше)
GitHub
. Бот crypto-ai-bot при деплое получает URL своего Prometheus (или Prometheus – знает URL бота) и таким образом интегрируется. Такое разделение обеспечивает, что сбои мониторинга не влияют на торговый алгоритм, а также позволяет централизованно наблюдать за несколькими инстансами бота (если их несколько) одной системой мониторинга.

Логирование и трассировка: Дополнительно к метрикам, бот пишет подробные логи (в JSON-формате, если настроено) на stdout. В продакшене (Railway) эти логи собираются и могут просматриваться через интерфейс Railway или отправляться в сторонний log management (например, Datadog, ELK-stack) при необходимости. Каждый цикл orchestrator логируется с trace_id, так что при расследовании инцидентов можно собрать все сообщения, связанные с конкретным запуском стратегии.

Подводя итог, мониторинг crypto-ai-bot включает три уровня: метрики (Prometheus), health-checks (Alertmanager + Telegram), и логи (ручной анализ или алертинг по ключевым словам). Использование внешнего репозитория crypto-bot-monitoring позволяет легко обновлять и настраивать мониторинг без затрагивания кода бота, а также соблюдать лучшие практики DevOps (инфраструктура как код)
GitHub
.

Контакты

Проект поддерживается и развивается внутри команды. Для вопросов по архитектуре или внесения вклада вы можете связаться с автором и главным разработчиком: Sabir Şahbaz (GitHub: sabiraka1) 
GitHub
. Также приветствуется создание Issue или Pull Request в репозитории на GitHub для отслеживания багов и предложений.

Если вы новый участник команды, по всем организационным моментам (доступы к Railway, переменным окружения, ключам API, etc.) обращайтесь к тимлиду или DevOps инженеру, чтобы получить необходимые креденшлы. Технические вопросы можно обсудить в внутреннем Slack-канале проекта или в чате разработчиков.

Спасибо за интерес к проекту crypto-ai-bot! Надеемся, этот README помог вам разобраться в устройстве системы. Удачной разработки и прибыльной торговли!