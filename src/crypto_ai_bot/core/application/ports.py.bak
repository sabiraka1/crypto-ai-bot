"""
Ports (contracts) between application and infrastructure layers.
Single source of truth for all interfaces.

Rules:
- Application works ONLY through these interfaces
- Infrastructure implements these interfaces
- Domain knows nothing about these interfaces (pure business logic)
"""
from __future__ import annotations

from abc import ABC, abstractmethod
from contextlib import asynccontextmanager
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any, AsyncIterator, Optional, Protocol, runtime_checkable

from crypto_ai_bot.utils.decimal import dec


# ============= ENUMS =============

class OrderStatus(Enum):
    """Order status states"""
    PENDING = "pending"
    OPEN = "open"
    CLOSED = "closed"
    CANCELED = "canceled"
    REJECTED = "rejected"
    EXPIRED = "expired"
    PARTIALLY_FILLED = "partially_filled"


class OrderSide(Enum):
    """Order side (buy/sell)"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """Order type"""
    MARKET = "market"
    LIMIT = "limit"
    STOP_LOSS = "stop_loss"
    STOP_LIMIT = "stop_limit"
    TRAILING_STOP = "trailing_stop"


class PositionSide(Enum):
    """Position side (SPOT only supports LONG)"""
    LONG = "long"


# ============= DTOs =============

@dataclass(frozen=True)
class TickerDTO:
    """Market ticker data"""
    symbol: str
    last: Decimal
    bid: Decimal
    ask: Decimal
    spread_pct: Decimal
    volume_24h: Decimal
    timestamp: datetime


@dataclass(frozen=True)
class BalanceDTO:
    """Account balance by currency"""
    currency: str
    free: Decimal
    used: Decimal
    total: Decimal


@dataclass(frozen=True)
class OrderDTO:
    """Order data"""
    id: str
    client_order_id: str
    symbol: str
    side: OrderSide
    type: OrderType
    status: OrderStatus
    price: Optional[Decimal]
    amount: Decimal
    filled: Decimal
    remaining: Decimal
    fee: Decimal
    fee_currency: str
    timestamp: datetime
    info: dict[str, Any]  # Raw exchange data


@dataclass(frozen=True)
class PositionDTO:
    """Open position data"""
    symbol: str
    side: PositionSide
    amount: Decimal
    entry_price: Decimal
    current_price: Decimal
    unrealized_pnl: Decimal
    realized_pnl: Decimal
    timestamp: datetime


@dataclass(frozen=True)
class TradeDTO:
    """Executed trade data"""
    id: str
    order_id: str
    symbol: str
    side: OrderSide
    price: Decimal
    amount: Decimal
    fee: Decimal
    fee_currency: str
    timestamp: datetime


@dataclass(frozen=True)
class MacroDataDTO:
    """Macro market data (DXY, BTC.D, FOMC)"""
    source: str  # "dxy" | "btc_dominance" | "fomc"
    value: Decimal
    change_pct: Decimal
    timestamp: datetime
    metadata: dict[str, Any]


# ============= BROKER PORT =============

@runtime_checkable
class BrokerPort(Protocol):
    """
    Interface for exchange operations.
    Implementations: CCXTAdapter (live), PaperBroker (test)
    """
    
    # Market Data
    async def fetch_ticker(self, symbol: str) -> TickerDTO:
        """Get current ticker prices"""
        ...
    
    async def fetch_ohlcv(
        self, 
        symbol: str, 
        timeframe: str, 
        limit: int = 100
    ) -> list[tuple[datetime, Decimal, Decimal, Decimal, Decimal, Decimal]]:
        """Get OHLCV candles (time, open, high, low, close, volume)"""
        ...
    
    # Account
    async def fetch_balance(self) -> dict[str, BalanceDTO]:
        """Get account balances"""
        ...
    
    async def fetch_position(self, symbol: str) -> Optional[PositionDTO]:
        """Get open position for symbol"""
        ...
    
    # Orders
    async def create_market_order(
        self,
        symbol: str,
        side: OrderSide,
        amount: Decimal,
        client_order_id: str
    ) -> OrderDTO:
        """Create market order"""
        ...
    
    async def create_limit_order(
        self,
        symbol: str,
        side: OrderSide,
        amount: Decimal,
        price: Decimal,
        client_order_id: str
    ) -> OrderDTO:
        """Create limit order"""
        ...
    
    async def create_stop_loss_order(
        self,
        symbol: str,
        amount: Decimal,
        stop_price: Decimal,
        client_order_id: str
    ) -> OrderDTO:
        """Create stop-loss order"""
        ...
    
    async def cancel_order(
        self,
        order_id: str,
        symbol: str
    ) -> OrderDTO:
        """Cancel order"""
        ...
    
    async def fetch_order(
        self,
        order_id: str,
        symbol: str
    ) -> OrderDTO:
        """Get order info"""
        ...
    
    async def fetch_open_orders(
        self,
        symbol: Optional[str] = None
    ) -> list[OrderDTO]:
        """Get open orders"""
        ...
    
    async def fetch_closed_orders(
        self,
        symbol: str,
        since: Optional[datetime] = None,
        limit: int = 100
    ) -> list[OrderDTO]:
        """Get closed orders"""
        ...


# ============= STORAGE PORTS (SEPARATED) =============

@runtime_checkable
class TradeStoragePort(Protocol):
    """Trade storage operations"""
    
    async def save_trade(
        self,
        trade_id: str,
        symbol: str,
        side: str,
        amount: Decimal,
        price: Decimal,
        fee: Decimal,
        timestamp: datetime,
        metadata: dict[str, Any]
    ) -> None:
        """Save trade to storage"""
        ...
    
    async def get_trades(
        self,
        symbol: str,
        since: Optional[datetime] = None,
        limit: int = 100
    ) -> list[dict[str, Any]]:
        """Get trades from storage"""
        ...
    
    async def get_daily_pnl(
        self,
        symbol: str,
        date: Optional[datetime] = None
    ) -> Decimal:
        """Calculate daily PnL"""
        ...
    
    async def get_total_pnl(
        self,
        symbol: str,
        since: Optional[datetime] = None
    ) -> Decimal:
        """Calculate total PnL"""
        ...


@runtime_checkable
class OrderStoragePort(Protocol):
    """Order storage operations"""
    
    async def save_order(
        self,
        order_id: str,
        client_order_id: str,
        symbol: str,
        side: str,
        type: str,
        amount: Decimal,
        price: Optional[Decimal],
        status: str,
        timestamp: datetime,
        metadata: dict[str, Any]
    ) -> None:
        """Save order to storage"""
        ...
    
    async def get_order(
        self,
        order_id: Optional[str] = None,
        client_order_id: Optional[str] = None
    ) -> Optional[dict[str, Any]]:
        """Get order by ID"""
        ...
    
    async def update_order_status(
        self,
        order_id: str,
        status: str,
        filled: Decimal,
        timestamp: datetime
    ) -> None:
        """Update order status"""
        ...
    
    async def is_idempotent_key_used(
        self,
        key: str,
        bucket_ms: int
    ) -> bool:
        """Check if idempotency key was used"""
        ...
    
    async def save_idempotent_key(
        self,
        key: str,
        timestamp: datetime
    ) -> None:
        """Save idempotency key"""
        ...


@runtime_checkable
class PositionStoragePort(Protocol):
    """Position storage operations"""
    
    async def save_position(
        self,
        symbol: str,
        side: str,
        amount: Decimal,
        entry_price: Decimal,
        timestamp: datetime
    ) -> None:
        """Save position to storage"""
        ...
    
    async def get_position(self, symbol: str) -> Optional[dict[str, Any]]:
        """Get current position"""
        ...
    
    async def close_position(
        self,
        symbol: str,
        exit_price: Decimal,
        realized_pnl: Decimal,
        timestamp: datetime
    ) -> None:
        """Close position"""
        ...


@runtime_checkable
class RiskStoragePort(Protocol):
    """Risk counter storage operations"""
    
    async def increment_risk_counter(
        self,
        rule: str,
        symbol: str,
        value: Decimal = dec("1")
    ) -> None:
        """Increment risk counter"""
        ...
    
    async def get_risk_counter(
        self,
        rule: str,
        symbol: str,
        since: Optional[datetime] = None
    ) -> Decimal:
        """Get risk counter value"""
        ...
    
    async def reset_risk_counters(
        self,
        symbol: str,
        before: Optional[datetime] = None
    ) -> None:
        """Reset risk counters"""
        ...


# ============= EVENT BUS PORT =============

@runtime_checkable
class EventBusPort(Protocol):
    """
    Event bus interface.
    Implementations: InMemoryBus, RedisBus
    """
    
    async def publish(
        self,
        topic: str,
        payload: dict[str, Any],
        trace_id: Optional[str] = None
    ) -> None:
        """Publish event to topic"""
        ...
    
    async def subscribe(
        self,
        topic: str,
        handler: callable
    ) -> None:
        """Subscribe to topic events"""
        ...
    
    async def start(self) -> None:
        """Start event bus"""
        ...
    
    async def stop(self) -> None:
        """Stop event bus"""
        ...


# ============= MACRO DATA PORT =============

@runtime_checkable
class MacroDataPort(Protocol):
    """
    Macro market data interface.
    Implementations: DXYSource, BTCDominanceSource, FOMCSource
    """
    
    async def fetch_latest(self) -> MacroDataDTO:
        """Get latest macro data"""
        ...
    
    async def fetch_history(
        self,
        days: int = 7
    ) -> list[MacroDataDTO]:
        """Get historical macro data"""
        ...


# ============= SAFETY PORTS =============

@runtime_checkable
class DeadMansSwitchPort(Protocol):
    """
    Dead Man's Switch for emergency shutdown.
    Implementation: DeadMansSwitch
    """
    
    async def start(
        self,
        timeout_ms: int,
        callback: callable
    ) -> None:
        """Start DMS with timeout and callback"""
        ...
    
    async def ping(self) -> None:
        """Reset timeout timer"""
        ...
    
    async def stop(self) -> None:
        """Stop DMS"""
        ...
    
    def is_active(self) -> bool:
        """Check if DMS is active"""
        ...


@runtime_checkable
class InstanceLockPort(Protocol):
    """
    Instance lock to prevent double launch.
    Implementations: FileInstanceLock, RedisInstanceLock
    """
    
    async def acquire(
        self,
        key: str,
        ttl: int = 3600
    ) -> bool:
        """Acquire exclusive lock"""
        ...
    
    async def release(self, key: str) -> None:
        """Release lock"""
        ...
    
    async def extend(
        self,
        key: str,
        ttl: int = 3600
    ) -> bool:
        """Extend lock TTL"""
        ...


# ============= NOTIFICATION PORT =============

@runtime_checkable
class NotificationPort(Protocol):
    """
    Notification interface.
    Implementation: TelegramNotifier
    """
    
    async def send_message(
        self,
        text: str,
        level: str = "info",
        metadata: Optional[dict[str, Any]] = None
    ) -> None:
        """Send notification message"""
        ...
    
    async def send_alert(
        self,
        title: str,
        message: str,
        trace_id: Optional[str] = None
    ) -> None:
        """Send critical alert"""
        ...
    
    async def send_trade_report(
        self,
        symbol: str,
        side: str,
        amount: Decimal,
        price: Decimal,
        pnl: Optional[Decimal] = None
    ) -> None:
        """Send trade execution report"""
        ...


# ============= METRICS PORT =============

@runtime_checkable
class MetricsPort(Protocol):
    """
    Metrics collection interface.
    Implementation: PrometheusMetrics
    """
    
    def increment(
        self,
        name: str,
        value: float = 1.0,
        labels: Optional[dict[str, str]] = None
    ) -> None:
        """Increment counter metric"""
        ...
    
    def gauge(
        self,
        name: str,
        value: float,
        labels: Optional[dict[str, str]] = None
    ) -> None:
        """Set gauge metric value"""
        ...
    
    def histogram(
        self,
        name: str,
        value: float,
        labels: Optional[dict[str, str]] = None
    ) -> None:
        """Record histogram value"""
        ...
    
    @asynccontextmanager
    async def timer(
        self,
        name: str,
        labels: Optional[dict[str, str]] = None
    ) -> AsyncIterator[None]:
        """Context manager for timing operations"""
        ...


# ============= COMPOSITE STORAGE PORT =============

@runtime_checkable
class StoragePort(Protocol):
    """
    Composite storage interface combining all storage ports.
    Implementation: SQLiteStorage
    """
    
    @property
    def trades(self) -> TradeStoragePort:
        """Trade storage operations"""
        ...
    
    @property
    def orders(self) -> OrderStoragePort:
        """Order storage operations"""
        ...
    
    @property
    def positions(self) -> PositionStoragePort:
        """Position storage operations"""
        ...
    
    @property
    def risk(self) -> RiskStoragePort:
        """Risk counter storage operations"""
        ...


# ============= NO-OP IMPLEMENTATIONS =============

class NoopDeadMansSwitch:
    """No-op Dead Man's Switch for testing"""
    
    def __init__(self) -> None:
        self._active = False
    
    async def start(self, timeout_ms: int, callback: callable) -> None:
        """NOOP: DMS start (callback not called)"""
        self._active = True
        # WARNING: callback is not stored/called in noop mode
    
    async def ping(self) -> None:
        """NOOP: DMS ping"""
        pass
    
    async def stop(self) -> None:
        """NOOP: DMS stop"""
        self._active = False
    
    def is_active(self) -> bool:
        return self._active


class NoopInstanceLock:
    """No-op Instance Lock for testing"""
    
    async def acquire(self, key: str, ttl: int = 3600) -> bool:
        """NOOP: always acquires lock successfully"""
        return True
    
    async def release(self, key: str) -> None:
        """NOOP: lock release"""
        pass
    
    async def extend(self, key: str, ttl: int = 3600) -> bool:
        """NOOP: lock extend"""
        return True


class NoopEventBus:
    """No-op Event Bus for testing"""
    
    def __init__(self) -> None:
        self._handlers: dict[str, list[callable]] = {}
        self._published: list[tuple[str, dict[str, Any], Optional[str]]] = []  # For testing
    
    async def publish(
        self, 
        topic: str, 
        payload: dict[str, Any], 
        trace_id: Optional[str] = None
    ) -> None:
        """NOOP: event publish (stores for testing)"""
        self._published.append((topic, payload, trace_id))
        # Optionally call handlers in test mode
        if topic in self._handlers:
            for handler in self._handlers[topic]:
                try:
                    await handler(payload)
                except Exception:
                    pass  # Ignore errors in noop mode
    
    async def subscribe(self, topic: str, handler: callable) -> None:
        """NOOP: event subscribe"""
        if topic not in self._handlers:
            self._handlers[topic] = []
        self._handlers[topic].append(handler)
    
    async def start(self) -> None:
        """NOOP: bus start"""
        pass
    
    async def stop(self) -> None:
        """NOOP: bus stop"""
        self._published.clear()
        self._handlers.clear()
    
    def get_published(self) -> list[tuple[str, dict[str, Any], Optional[str]]]:
        """Get published events for testing"""
        return self._published.copy()


class NoopNotification:
    """No-op Notification for testing"""
    
    async def send_message(
        self, 
        text: str, 
        level: str = "info", 
        metadata: Optional[dict[str, Any]] = None
    ) -> None:
        """NOOP: message send"""
        pass
    
    async def send_alert(
        self, 
        title: str, 
        message: str, 
        trace_id: Optional[str] = None
    ) -> None:
        """NOOP: alert send"""
        pass
    
    async def send_trade_report(
        self, 
        symbol: str, 
        side: str, 
        amount: Decimal, 
        price: Decimal, 
        pnl: Optional[Decimal] = None
    ) -> None:
        """NOOP: trade report send"""
        pass


class NoopMetrics:
    """No-op Metrics for testing"""
    
    def increment(
        self, 
        name: str, 
        value: float = 1.0, 
        labels: Optional[dict[str, str]] = None
    ) -> None:
        """NOOP: metric increment"""
        pass
    
    def gauge(
        self, 
        name: str, 
        value: float, 
        labels: Optional[dict[str, str]] = None
    ) -> None:
        """NOOP: gauge set"""
        pass
    
    def histogram(
        self, 
        name: str, 
        value: float, 
        labels: Optional[dict[str, str]] = None
    ) -> None:
        """NOOP: histogram record"""
        pass
    
    @asynccontextmanager
    async def timer(
        self, 
        name: str, 
        labels: Optional[dict[str, str]] = None
    ) -> AsyncIterator[None]:
        """NOOP: timer context"""
        yield


# ============= EXPORT =============

__all__ = [
    # Enums
    "OrderStatus",
    "OrderSide",
    "OrderType",
    "PositionSide",
    
    # DTOs
    "TickerDTO",
    "BalanceDTO",
    "OrderDTO",
    "PositionDTO",
    "TradeDTO",
    "MacroDataDTO",
    
    # Main Ports
    "BrokerPort",
    "StoragePort",
    "EventBusPort",
    "MacroDataPort",
    "DeadMansSwitchPort",
    "InstanceLockPort",
    "NotificationPort",
    "MetricsPort",
    
    # Storage Sub-Ports
    "TradeStoragePort",
    "OrderStoragePort",
    "PositionStoragePort",
    "RiskStoragePort",
    
    # No-op implementations
    "NoopDeadMansSwitch",
    "NoopInstanceLock",
    "NoopEventBus",
    "NoopNotification",
    "NoopMetrics",
]