from __future__ import annotations
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Protocol, runtime_checkable

@runtime_checkable
class PositionRepositoryInterface(Protocol):
    def get_open(self) -> List[Dict[str, Any]]: ...
    def add(self, pos: Dict[str, Any]) -> None: ...
    def close(self, pos_id: Any, *, pnl: Optional[float] = None) -> None: ...

@runtime_checkable
class TradeRepositoryInterface(Protocol):
    def last_closed_pnls(self, n: int) -> List[float]: ...
    def list_all(self) -> Optional[List[Dict[str, Any]]]: ...
    def list_closed(self, n: int) -> Optional[List[Dict[str, Any]]]: ...

@runtime_checkable
class AuditRepositoryInterface(Protocol):
    def add(self, event: Dict[str, Any]) -> None: ...

@runtime_checkable
class IdempotencyRepositoryInterface(Protocol):
    def claim(self, key: str, ttl_sec: int) -> bool: ...
    def commit(self, key: str, payload: Dict[str, Any]) -> None: ...
    def release(self, key: str) -> None: ...
    def check_and_store(self, key: str, payload: Dict[str, Any]) -> Optional[Dict[str, Any]]: ...

@runtime_checkable
class UnitOfWorkInterface(Protocol):
    def __enter__(self) -> "UnitOfWorkInterface": ...
    def __exit__(self, exc_type, exc, tb) -> None: ...
    def begin(self) -> None: ...
    def commit(self) -> None: ...
    def rollback(self) -> None: ...

@dataclass
class RepositoryInterfaces:
    positions: PositionRepositoryInterface
    trades: TradeRepositoryInterface
    audit: AuditRepositoryInterface
    idempotency: IdempotencyRepositoryInterface
    uow: UnitOfWorkInterface
    decisions: Optional[Any] = None
