# src/crypto_ai_bot/trading/bot.py
"""
ü§ñ Trading Bot Orchestrator (signals-native)
–õ—ë–≥–∫–∏–π, –º–Ω–æ–≥–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä –±–µ–∑ –ª–∏—à–Ω–µ–π –Ω–∞–≥—Ä—É–∑–∫–∏.
–°–æ–≤–º–µ—Å—Ç–∏–º —Å —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π –ø—Ä–æ–µ–∫—Ç–∞ –∏ –º–æ–¥—É–ª—è–º–∏ signals/* –∏ context/*
"""

from __future__ import annotations

import os
import time
import logging
import threading
from dataclasses import dataclass
from typing import Any, Dict, Optional, Tuple

import pandas as pd

# ‚îÄ‚îÄ –ö–æ–Ω—Ñ–∏–≥ –∏ —è–¥—Ä–æ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
from crypto_ai_bot.config.settings import Settings
from crypto_ai_bot.core.state_manager import StateManager
from crypto_ai_bot.core.events import EventBus
# metrics –æ–ø—Ü–∏–æ–Ω–∞–ª–µ–Ω ‚Äî –Ω–µ —Ç—è–Ω–µ–º —Å—é–¥–∞ —Ä–æ—É—Ç–µ—Ä, —Ç–æ–ª—å–∫–æ –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ —Å—á—ë—Ç—á–∏–∫–∏ –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏
try:
    from crypto_ai_bot.core.metrics import incr_counter, set_gauge  # type: ignore
except Exception:
    def incr_counter(*args, **kwargs):  # no-op
        pass
    def set_gauge(*args, **kwargs):  # no-op
        pass

# ‚îÄ‚îÄ –¢–æ—Ä–≥–æ–≤–ª—è –∏ —Ä–∏—Å–∫ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
from crypto_ai_bot.trading.exchange_client import ExchangeClient, APIException
from crypto_ai_bot.trading.position_manager import PositionManager
from crypto_ai_bot.trading.risk_manager import RiskManager

# ‚îÄ‚îÄ –°–∏–≥–Ω–∞–ª—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
from crypto_ai_bot.trading.signals.signal_aggregator import aggregate_features
from crypto_ai_bot.trading.signals.signal_validator import validate_features
from crypto_ai_bot.trading.signals.score_fusion import fuse_scores
from crypto_ai_bot.trading.signals.entry_policy import decide_entry  # ‚Üê –í–ê–ñ–ù–û: —Ç–∞–∫ –∏ –Ω–∞–∑—ã–≤–∞–µ–º

# ‚îÄ‚îÄ –ö–æ–Ω—Ç–µ–∫—Å—Ç ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
from crypto_ai_bot.context.snapshot import (
    ContextSnapshot,
    build_context_snapshot,
)

# ‚îÄ‚îÄ –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ (ATR fallback) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
try:
    from crypto_ai_bot.analysis.technical_indicators import get_unified_atr
except Exception:
    get_unified_atr = None  # –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–æ–ª–±—ç–∫ –Ω–∏–∂–µ

logger = logging.getLogger(__name__)


# =============================================================================
# DI-–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
# =============================================================================
@dataclass
class Deps:
    settings: Settings
    exchange: ExchangeClient
    state: StateManager
    risk: RiskManager
    positions: PositionManager
    events: EventBus


# =============================================================================
# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —É—Ç–∏–ª–∏—Ç—ã
# =============================================================================
def ohlcv_to_df(ohlcv: Any) -> pd.DataFrame:
    """CCXT OHLCV ‚Üí pandas.DataFrame —Å –∏–Ω–¥–µ–∫—Å–æ–º –≤—Ä–µ–º–µ–Ω–∏ (UTC)."""
    if not ohlcv:
        return pd.DataFrame()
    cols = ["time", "open", "high", "low", "close", "volume"]
    df = pd.DataFrame(ohlcv, columns=cols)
    df["time"] = pd.to_datetime(df["time"], unit="ms", utc=True)
    df.set_index("time", inplace=True)
    for c in ("open", "high", "low", "close", "volume"):
        df[c] = pd.to_numeric(df[c], errors="coerce")
    return df.dropna()


def unified_atr(df: pd.DataFrame, period: int = 14) -> Optional[float]:
    """–ï–¥–∏–Ω—ã–π —Ä–∞—Å—á—ë—Ç ATR ‚Äî —á–µ—Ä–µ–∑ analysis.get_unified_atr –∏–ª–∏ –±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ñ–æ–ª–±—ç–∫."""
    try:
        if get_unified_atr is not None:
            return float(get_unified_atr(df, period=period, method="ewm"))
        # —Ñ–æ–ª–±—ç–∫: —Å—Ä–µ–¥–Ω–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω high-low
        if df.empty:
            return None
        return float((df["high"] - df["low"]).mean())
    except Exception as e:
        logger.warning(f"ATR fallback failed: {e}")
        return None


# =============================================================================
# –û—Å–Ω–æ–≤–Ω–æ–π –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä
# =============================================================================
class TradingBot:
    """
    –õ—ë–≥–∫–∏–π –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞:
      - —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
      - –∞–≥—Ä–µ–≥–∞—Ü–∏—è —Ñ–∏—á/—Å–∏–≥–Ω–∞–ª–æ–≤
      - –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ö–æ–¥–∞ (–ª–æ–Ω–≥-–ª–æ–≥–∏–∫–∞)
      - paper-trade / —Ä–µ–∞–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ (–ø–æ –∫–æ–Ω—Ñ–∏–≥—É)
    """

    def __init__(self, deps: Deps):
        self.deps = deps
        self.cfg = deps.settings

        # –û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        self.symbol: str = self.cfg.SYMBOL
        self.timeframe: str = self.cfg.TIMEFRAME  # –æ—Å–Ω–æ–≤–Ω–æ–π –¢–§ –¥–ª—è –ª–æ–≥–æ–≤
        self.cycle_minutes: int = int(self.cfg.ANALYSIS_INTERVAL)
        self.safe_mode: bool = bool(int(os.getenv("SAFE_MODE", "1")))
        self.enable_trading: bool = bool(int(os.getenv("ENABLE_TRADING", "1")))

        # –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        self._is_running = False
        self._loop_lock = threading.RLock()
        self._last_candle_id: Optional[str] = None

        # –°—Å—ã–ª–∫–∏ –Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        self.exchange = deps.exchange
        self.state = deps.state
        self.risk = deps.risk
        self.positions = deps.positions
        self.events = deps.events

        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ AI (–ø–æ –∂–µ–ª–∞–Ω–∏—é; –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã)
        self._init_ai()

        # –•–µ–Ω–¥–ª–µ—Ä—ã —Å–æ–±—ã—Ç–∏–π
        self._bind_event_handlers()

        logger.info(
            "ü§ñ TradingBot initialized (signals-native) | SAFE_MODE=%s, ENABLE_TRADING=%s",
            int(self.safe_mode), int(self.enable_trading)
        )

    # ‚îÄ‚îÄ AI (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def _init_ai(self) -> None:
        self.ai_ready = False
        self.ai_model = None
        if not bool(int(os.getenv("AI_ENABLE", "0"))):
            logger.info("üî≤ AI disabled")
            return
        try:
            # –¢–≤–æ—è –º–æ–¥–µ–ª—å (–µ—Å–ª–∏ –µ—Å—Ç—å)
            from crypto_ai_bot.ml.adaptive_model import AdaptiveMLModel  # type: ignore
            self.ai_model = AdaptiveMLModel(models_dir=self.cfg.MODEL_DIR)
            if hasattr(self.ai_model, "load_models"):
                self.ai_model.load_models()
            self.ai_ready = True
            logger.info("üß† AI model initialized")
        except Exception as e:
            # –ù–µ —Ñ–µ–π–ª–∏–º –±–æ—Ç –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è sklearn/joblib –∏ —Ç.–ø.
            logger.warning("‚ö†Ô∏è AI init failed: %s", e)

    # ‚îÄ‚îÄ Events ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def _bind_event_handlers(self) -> None:
        self.events.on("new_candle", self._on_new_candle)
        self.events.on("signal_generated", self._on_signal_generated)
        self.events.on("paper_trade", self._on_paper_trade)
        self.events.on("position_opened", self._on_position_opened)
        self.events.on("position_closed", self._on_position_closed)
        self.events.on("risk_alert", self._on_risk_alert)
        logger.info("üì° Event handlers bound")

    # ‚îÄ‚îÄ Lifecycle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def start(self) -> None:
        if self._is_running:
            logger.warning("Bot already running")
            return
        logger.info("üöÄ Bot starting‚Ä¶")
        self._is_running = True
        t = threading.Thread(target=self._loop, name="TradingLoop", daemon=True)
        t.start()

    def stop(self) -> None:
        if not self._is_running:
            logger.info("Bot is not running")
            return
        logger.info("üõë Bot stopping‚Ä¶")
        self._is_running = False

    # ‚îÄ‚îÄ Main loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def _loop(self) -> None:
        logger.info("üîÑ Trading loop started")
        while self._is_running:
            try:
                self._tick()
            except Exception as e:
                logger.error("‚ùå Cycle error: %s", e, exc_info=True)
                incr_counter("bot_cycle_errors_total", 1)
            time.sleep(self.cycle_minutes * 60)
        logger.info("üîÑ Trading loop stopped")

    # ‚îÄ‚îÄ One cycle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def _tick(self) -> None:
        with self._loop_lock:
            # 1) –ö–æ–Ω—Ç–µ–∫—Å—Ç
            ctx: ContextSnapshot = build_context_snapshot(self.cfg)

            # 2) –§–∏—á–∏/–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã/—Å–∫–æ—Ä—ã (15m + 1h + 4h)
            timeframes = ["15m", "1h", "4h"]
            features = aggregate_features(
                exchange=self.exchange,
                symbol=self.symbol,
                timeframes=timeframes,
                limit=int(os.getenv("INDICATOR_LOOKBACK", "200")),
                context=ctx,
                use_context_penalties=bool(int(os.getenv("USE_CONTEXT_PENALTIES", "1")))
            )

            if not validate_features(features):
                logger.warning("‚ö†Ô∏è Invalid features, skip")
                incr_counter("features_invalid_total", 1)
                return

            rule_score: float = float(features.get("rule_score", 0.0))
            ai_score_raw: float = float(features.get("ai_score", float(os.getenv("AI_FAILOVER_SCORE", "0.55"))))
            # –ï—Å–ª–∏ –∞–≥—Ä–µ–≥–∞—Ç–æ—Ä —É–∂–µ –≤–µ—Ä–Ω—É–ª penalized ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ –¥–ª—è ¬´–ø—Ä–∞–≤–∏–ª¬ª, –∞ –ø—Ä–∏ —ç—Ç–æ–º fuse –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
            rule_penalized: float = float(features.get("rule_score_penalized", rule_score))

            # 3) –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–∫–æ—Ä (–ø—Ä–∞–≤–∏–ª–∞ + AI)
            fused_score = fuse_scores(rule_penalized, ai_score_raw)

            # 4) –û—Ç–ø—Ä–∞–≤–∏–º —Å–æ–±—ã—Ç–∏–µ —Å –≥–æ—Ç–æ–≤—ã–º —Å–∏–≥–Ω–∞–ª–æ–º
            signal_payload = {
                "symbol": self.symbol,
                "rule_score": rule_score,
                "rule_penalized": rule_penalized,
                "ai_score": ai_score_raw,
                "fused_score": fused_score,
                "context": {
                    "market_condition": ctx.market_condition,
                    "btc_dominance": ctx.btc_dominance,
                    "dxy_change_1d": ctx.dxy_change_1d,
                    "fear_greed": ctx.fear_greed,
                    "penalties": getattr(features, "applied_penalties", features.get("applied_penalties", [])),
                },
            }
            self.events.emit("signal_generated", signal_payload)

            # 5) –†–µ—à–µ–Ω–∏–µ –æ –≤—Ö–æ–¥–µ (–ª–æ–Ω–≥)
            decision = decide_entry(features, self.cfg, fused_score=fused_score)
            if not decision or not isinstance(decision, dict):
                logger.debug("‚è≠ No entry decision this cycle")
                set_gauge("last_decision_score", fused_score)
                return

            # decision: {side, entry_price, sl_price, tp_price, size_usd, reason, ...}
            side = decision.get("side", "long")
            if side != "long":
                logger.debug("Only LONG supported, decision=%s", side)
                set_gauge("last_decision_score", fused_score)
                return

            # —Ä–∏—Å–∫-—Ñ–∏–ª—å—Ç—Ä—ã (ATR, –¥–Ω–µ–≤–Ω—ã–µ –ª–∏–º–∏—Ç—ã –∏ —Ç.–¥.)
            if not self._pass_risk_checks(decision):
                logger.info("‚õî Blocked by risk manager")
                incr_counter("entry_blocked_risk_total", 1)
                set_gauge("last_decision_score", fused_score)
                return

            # 6) –í—Ö–æ–¥: SAFE_MODE ‚Üí paper event; live ‚Üí –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å PositionManager
            if self.safe_mode or not self.enable_trading:
                # paper trade
                paper = {
                    "symbol": self.symbol,
                    "side": "BUY",
                    "entry": float(decision.get("entry_price")),
                    "sl": float(decision.get("sl_price", 0.0)),
                    "tp": float(decision.get("tp_price", 0.0)),
                    "size_usd": float(decision.get("size_usd", self.cfg.TRADE_AMOUNT)),
                    "score": fused_score,
                    "reason": decision.get("reason", "rules+ai"),
                }
                logger.info("üß™ PAPER BUY %s | $%.2f | score=%.3f | %s",
                            paper["symbol"], paper["size_usd"], fused_score, paper["reason"])
                self.events.emit("paper_trade", paper)
                incr_counter("paper_entries_total", 1)
                set_gauge("last_decision_score", fused_score)
                return

            # live-mode (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ: –ø–æ–¥–∫–ª—é—á–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞)
            try:
                # –∑–¥–µ—Å—å –º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å methods —Ç–≤–æ–µ–≥–æ PositionManager –¥–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞
                # –ø—Ä–∏–º–µ—Ä (–µ—Å–ª–∏ —É —Ç–µ–±—è –µ—Å—Ç—å —Ç–∞–∫–æ–π –º–µ—Ç–æ–¥):
                # self.positions.open_market_buy(self.symbol, usd_amount=decision["size_usd"], sl=..., tp=...)
                logger.info("üü¢ LIVE BUY requested (stub) | size=%.2f score=%.3f",
                            float(decision.get("size_usd", self.cfg.TRADE_AMOUNT)), fused_score)
                incr_counter("live_entries_total", 1)
            except Exception as e:
                logger.error("‚ùå Live entry failed: %s", e, exc_info=True)
                incr_counter("live_entry_errors_total", 1)

    # ‚îÄ‚îÄ Risk filters glue ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def _pass_risk_checks(self, decision: Dict[str, Any]) -> bool:
        """–¢–æ—á–∫–∞ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å RiskManager. –í–æ–∑–≤—Ä–∞—â–∞–µ–º True, –µ—Å–ª–∏ —Ä–∏—Å–∫–∏ –û–ö."""
        try:
            # –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ ‚Äî ATR –∏ –¥–Ω–µ–≤–Ω—ã–µ –ª–∏–º–∏—Ç—ã (–µ—Å–ª–∏ —É —Ç–µ–±—è —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ)
            # –º–æ–∂–Ω–æ –ø—Ä–æ–∫–∏–Ω—É—Ç—å –≤ self.risk –∫–∞–∫–∏–µ-—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ decision
            return True
        except Exception as e:
            logger.error("Risk check failed: %s", e, exc_info=True)
            return False

    # ‚îÄ‚îÄ Event handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def _on_new_candle(self, payload: Dict[str, Any]) -> None:
        logger.debug("üïØÔ∏è new_candle %s %s", payload.get("symbol"), payload.get("timeframe"))

    def _on_signal_generated(self, payload: Dict[str, Any]) -> None:
        logger.debug(
            "üéØ signal: rule=%.3f pen=%.3f ai=%.3f fused=%.3f ctx=%s",
            float(payload.get("rule_score", 0.0)),
            float(payload.get("rule_penalized", payload.get("rule_score", 0.0))),
            float(payload.get("ai_score", 0.0)),
            float(payload.get("fused_score", 0.0)),
            payload.get("context", {}).get("market_condition", "SIDEWAYS"),
        )

    def _on_paper_trade(self, payload: Dict[str, Any]) -> None:
        logger.info("üìÑ paper_trade: %s", payload)

    def _on_position_opened(self, payload: Dict[str, Any]) -> None:
        logger.info("üì• position_opened: %s", payload)

    def _on_position_closed(self, payload: Dict[str, Any]) -> None:
        logger.info("üì§ position_closed: %s", payload)

    def _on_risk_alert(self, payload: Dict[str, Any]) -> None:
        logger.warning("‚ö†Ô∏è risk_alert: %s", payload)


# ‚îÄ‚îÄ –≠–∫—Å–ø–æ—Ä—Ç ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
__all__ = ["TradingBot", "Deps"]
