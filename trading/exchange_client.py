import ccxt
import logging
import threading
import time
import os
import csv
from datetime import datetime, timezone
from typing import Optional, Dict, Any, List
from decimal import Decimal, ROUND_DOWN


class APIException(Exception):
    """–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è –æ—à–∏–±–æ–∫ API –±–∏—Ä–∂–∏"""
    pass


class ExchangeClient:
    """
    –ü–æ–ª–Ω–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∫–ª–∏–µ–Ω—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Gate.io API.
    
    –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
    - SAFE MODE: —Å–∏–º—É–ª—è—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–ª–∏ —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ —Ü–µ–Ω–∞–º–∏
    - LIVE MODE: —Ä–µ–∞–ª—å–Ω–∞—è —Ç–æ—Ä–≥–æ–≤–ª—è 
    - –ï–¥–∏–Ω—ã–π CSV –¥–ª—è –≤—Å–µ—Ö —Å–¥–µ–ª–æ–∫ —Å –∫–æ–ª–æ–Ω–∫–æ–π mode (SAFE/LIVE)
    - –ê–≤—Ç–æ—Å–æ–∑–¥–∞–Ω–∏–µ CSV —Ñ–∞–π–ª–æ–≤
    - –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∏ –∑–∞–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π
    - –¶–µ–Ω—ã –∏ –∞–Ω–∞–ª–∏–∑ –≤—Å–µ–≥–¥–∞ —Å —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ä—ã–Ω–∫–∞
    """

    def __init__(self, api_key: str = None, api_secret: str = None, safe_mode: bool = True, csv_file: str = "trades.csv"):
        # –û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        self.safe_mode = safe_mode
        self.api_key = api_key or os.getenv("GATE_API_KEY", "")
        self.api_secret = api_secret or os.getenv("GATE_API_SECRET", "")
        self.csv_file = csv_file
        self._lock = threading.RLock()
        
        # –ö—ç—à –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ä—ã–Ω–∫–∞—Ö
        self._markets_cache = {}
        self._cache_timestamp = 0
        self._cache_ttl = 3600  # 1 —á–∞—Å
        
        # –°–∏–º—É–ª—è—Ü–∏—è –±–∞–ª–∞–Ω—Å–∞ –¥–ª—è SAFE MODE
        self._paper_balances = {
            "USDT": 10000.0,  # –°—Ç–∞—Ä—Ç–æ–≤—ã–π –±–∞–ª–∞–Ω—Å –≤ USDT
            "BTC": 0.0,
            "ETH": 0.0,
        }
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è CSV
        self._init_csv()
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∏—Ä–∂–µ
        self.exchange = None
        self._init_exchange()
        
        mode_text = "SAFE MODE (paper trading)" if self.safe_mode else "LIVE MODE (real trading)"
        logging.info(f"üè¶ Exchange client initialized in {mode_text}")

    def _init_csv(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è CSV —Ñ–∞–π–ª–∞ —Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏"""
        if not os.path.exists(self.csv_file):
            fieldnames = [
                "timestamp", "symbol", "side", "amount", "price", 
                "cost", "mode", "order_id", "status", "profit_pct", "profit_abs"
            ]
            with open(self.csv_file, mode="w", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()
            logging.info(f"üìÑ Created CSV file: {self.csv_file}")

    def _init_exchange(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∏—Ä–∂–µ"""
        try:
            # –í—Å–µ–≥–¥–∞ —Å–æ–∑–¥–∞–µ–º exchange –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Ä—ã–Ω–∫–∞
            self.exchange = ccxt.gateio({
                'apiKey': self.api_key if not self.safe_mode else "",
                'secret': self.api_secret if not self.safe_mode else "",
                'sandbox': False,
                'enableRateLimit': True,
                'timeout': 30000,
            })
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä—ã–Ω–∫–∏
            self.exchange.load_markets()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –≤ LIVE —Ä–µ–∂–∏–º–µ
            if not self.safe_mode and self.api_key and self.api_secret:
                # –¢–µ—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ API –∫–ª—é—á–µ–π
                self.exchange.fetch_balance()
                logging.info("‚úÖ Gate.io API connected successfully (LIVE MODE)")
            else:
                logging.info("‚úÖ Gate.io market data connected (SAFE MODE)")
                
        except Exception as e:
            if not self.safe_mode:
                logging.error(f"‚ùå Failed to initialize Gate.io API: {e}")
                logging.warning("üîÑ Falling back to SAFE MODE")
                self.safe_mode = True
            else:
                logging.warning(f"‚ö†Ô∏è Market data connection issues: {e}")

    def _log_trade(self, symbol: str, side: str, amount: float, price: float, 
                   cost: float = None, order_id: str = None, profit_pct: float = None, 
                   profit_abs: float = None):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–¥–µ–ª–∫–∏ –≤ CSV"""
        trade_data = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "symbol": symbol,
            "side": side,
            "amount": amount,
            "price": price,
            "cost": cost or (amount * price),
            "mode": "SAFE" if self.safe_mode else "LIVE",
            "order_id": order_id or f"{'sim' if self.safe_mode else 'real'}_{int(time.time()*1000)}",
            "status": "closed",
            "profit_pct": profit_pct or "",
            "profit_abs": profit_abs or ""
        }
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ –∏ —Å–æ–∑–¥–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        file_exists = os.path.isfile(self.csv_file)
        if not file_exists:
            self._init_csv()
            
        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å
        with open(self.csv_file, mode="a", newline="", encoding="utf-8") as file:
            fieldnames = list(trade_data.keys())
            writer = csv.DictWriter(file, fieldnames=fieldnames)
            writer.writerow(trade_data)
        
        logging.debug(f"üìä Trade logged: {side} {amount:.8f} {symbol} @ {price:.6f}")

    # ==================== MARKET DATA (–≤—Å–µ–≥–¥–∞ —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ) ====================

    def fetch_ohlcv(self, symbol: str, timeframe: str = "15m", limit: int = 200) -> List[List]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ OHLCV –¥–∞–Ω–Ω—ã—Ö - –≤—Å–µ–≥–¥–∞ —Å —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ä—ã–Ω–∫–∞"""
        try:
            if not self.exchange:
                self._init_exchange()

            ohlcv = self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
            if not ohlcv:
                raise APIException(f"No OHLCV data received for {symbol}")

            logging.debug(f"üìà Fetched {len(ohlcv)} candles for {symbol} {timeframe}")
            return ohlcv

        except Exception as e:
            logging.error(f"Failed to fetch OHLCV for {symbol}: {e}")
            raise APIException(f"OHLCV fetch failed: {e}")

    def get_last_price(self, symbol: str) -> float:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ü–µ–Ω—ã - –≤—Å–µ–≥–¥–∞ —Å —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ä—ã–Ω–∫–∞"""
        try:
            if not self.exchange:
                self._init_exchange()

            ticker = self.exchange.fetch_ticker(symbol)
            price = float(ticker.get('last', 0))

            if price <= 0:
                raise APIException(f"Invalid price received: {price}")

            logging.debug(f"üí∞ Last price {symbol}: {price:.6f}")
            return price

        except Exception as e:
            logging.error(f"Failed to get last price for {symbol}: {e}")
            raise APIException(f"Price fetch failed: {e}")

    # ==================== TRADING OPERATIONS ====================

    def create_market_buy_order(self, symbol: str, amount: float) -> Dict[str, Any]:
        """–°–æ–∑–¥–∞–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø–æ–∫—É–ø–∫—É"""
        
        with self._lock:
            try:
                # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É (–≤—Å–µ–≥–¥–∞ —Ä–µ–∞–ª—å–Ω—É—é)
                price = self.get_last_price(symbol)
                cost = amount * price
                
                if self.safe_mode:
                    # SAFE MODE: –°–∏–º—É–ª—è—Ü–∏—è –æ—Ä–¥–µ—Ä–∞
                    order_id = f"sim_buy_{int(time.time() * 1000)}"
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å USDT
                    usdt_balance = self._paper_balances.get("USDT", 0.0)
                    if cost > usdt_balance:
                        raise APIException(f"Insufficient USDT balance: {usdt_balance:.2f} < {cost:.2f}")
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º –±—É–º–∞–∂–Ω—ã–µ –±–∞–ª–∞–Ω—Å—ã
                    base_currency = symbol.split('/')[0]
                    self._paper_balances["USDT"] -= cost
                    self._paper_balances[base_currency] = self._paper_balances.get(base_currency, 0.0) + amount
                    
                    order_result = {
                        "id": order_id,
                        "symbol": symbol,
                        "amount": amount,
                        "price": price,
                        "cost": cost,
                        "side": "buy",
                        "type": "market",
                        "status": "closed",
                        "timestamp": int(time.time() * 1000),
                        "datetime": datetime.now(timezone.utc).isoformat(),
                        "paper": True
                    }
                    
                    logging.info(f"üìÑ PAPER BUY: {symbol} {amount:.8f} @ {price:.6f} (cost: {cost:.2f} USDT)")
                    
                else:
                    # LIVE MODE: –†–µ–∞–ª—å–Ω—ã–π –æ—Ä–¥–µ—Ä
                    if not self.exchange:
                        raise APIException("Exchange not initialized")
                    
                    # –û–∫—Ä—É–≥–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–≥–ª–∞—Å–Ω–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –±–∏—Ä–∂–∏
                    amount = self.round_amount(symbol, amount)
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
                    min_amount = self.market_min_amount(symbol)
                    min_cost = self.market_min_cost(symbol)
                    
                    if amount < min_amount:
                        raise APIException(f"Amount {amount} is below minimum {min_amount}")
                    if cost < min_cost:
                        raise APIException(f"Cost {cost:.2f} is below minimum {min_cost:.2f}")
                    
                    # –í—ã–ø–æ–ª–Ω—è–µ–º –æ—Ä–¥–µ—Ä
                    order_result = self.exchange.create_market_buy_order(symbol, amount)
                    
                    logging.info(f"‚úÖ LIVE BUY: {symbol} {amount:.8f} @ {order_result.get('price', price):.6f}")

                # –õ–æ–≥–∏—Ä—É–µ–º —Å–¥–µ–ª–∫—É
                self._log_trade(
                    symbol=symbol, 
                    side="buy", 
                    amount=amount, 
                    price=price, 
                    cost=cost,
                    order_id=order_result.get("id")
                )
                
                return order_result
                
            except Exception as e:
                logging.error(f"Failed to create buy order: {e}")
                raise APIException(f"Buy order failed: {e}")

    def create_market_sell_order(self, symbol: str, amount: float, entry_price: Optional[float] = None) -> Dict[str, Any]:
        """–°–æ–∑–¥–∞–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É"""
        
        with self._lock:
            try:
                # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É (–≤—Å–µ–≥–¥–∞ —Ä–µ–∞–ª—å–Ω—É—é)
                price = self.get_last_price(symbol)
                cost = amount * price
                
                # –†–∞—Å—á–µ—Ç –ø—Ä–∏–±—ã–ª–∏ –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–∞ —Ü–µ–Ω–∞ –≤—Ö–æ–¥–∞
                profit_pct = None
                profit_abs = None
                if entry_price and entry_price > 0:
                    profit_pct = round((price - entry_price) / entry_price * 100, 2)
                    profit_abs = round((price - entry_price) * amount, 4)
                
                if self.safe_mode:
                    # SAFE MODE: –°–∏–º—É–ª—è—Ü–∏—è –æ—Ä–¥–µ—Ä–∞
                    order_id = f"sim_sell_{int(time.time() * 1000)}"
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å –±–∞–∑–æ–≤–æ–π –≤–∞–ª—é—Ç—ã
                    base_currency = symbol.split('/')[0]
                    base_balance = self._paper_balances.get(base_currency, 0.0)
                    if amount > base_balance:
                        raise APIException(f"Insufficient {base_currency} balance: {base_balance:.8f} < {amount:.8f}")
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º –±—É–º–∞–∂–Ω—ã–µ –±–∞–ª–∞–Ω—Å—ã
                    self._paper_balances[base_currency] -= amount
                    self._paper_balances["USDT"] += cost
                    
                    order_result = {
                        "id": order_id,
                        "symbol": symbol,
                        "amount": amount,
                        "price": price,
                        "cost": cost,
                        "side": "sell",
                        "type": "market",
                        "status": "closed",
                        "timestamp": int(time.time() * 1000),
                        "datetime": datetime.now(timezone.utc).isoformat(),
                        "paper": True
                    }
                    
                    profit_text = f" (PnL: {profit_pct:+.2f}%)" if profit_pct is not None else ""
                    logging.info(f"üìÑ PAPER SELL: {symbol} {amount:.8f} @ {price:.6f}{profit_text}")
                    
                else:
                    # LIVE MODE: –†–µ–∞–ª—å–Ω—ã–π –æ—Ä–¥–µ—Ä
                    if not self.exchange:
                        raise APIException("Exchange not initialized")
                    
                    # –û–∫—Ä—É–≥–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–≥–ª–∞—Å–Ω–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –±–∏—Ä–∂–∏
                    amount = self.round_amount(symbol, amount)
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
                    min_amount = self.market_min_amount(symbol)
                    if amount < min_amount:
                        raise APIException(f"Amount {amount} is below minimum {min_amount}")
                    
                    # –í—ã–ø–æ–ª–Ω—è–µ–º –æ—Ä–¥–µ—Ä
                    order_result = self.exchange.create_market_sell_order(symbol, amount)
                    
                    profit_text = f" (PnL: {profit_pct:+.2f}%)" if profit_pct is not None else ""
                    logging.info(f"‚úÖ LIVE SELL: {symbol} {amount:.8f} @ {order_result.get('price', price):.6f}{profit_text}")

                # –õ–æ–≥–∏—Ä—É–µ–º —Å–¥–µ–ª–∫—É
                self._log_trade(
                    symbol=symbol, 
                    side="sell", 
                    amount=amount, 
                    price=price, 
                    cost=cost,
                    order_id=order_result.get("id"),
                    profit_pct=profit_pct,
                    profit_abs=profit_abs
                )
                
                return order_result
                
            except Exception as e:
                logging.error(f"Failed to create sell order: {e}")
                raise APIException(f"Sell order failed: {e}")

    # ==================== BALANCE MANAGEMENT ====================

    def get_balance(self, currency: str = "USDT") -> float:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –ø–æ –≤–∞–ª—é—Ç–µ"""
        
        try:
            if self.safe_mode:
                # SAFE MODE: –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –±–∞–ª–∞–Ω—Å
                balance = self._paper_balances.get(currency, 0.0)
                logging.debug(f"üìä PAPER balance {currency}: {balance:.8f}")
                return balance
            
            # LIVE MODE: –†–µ–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å
            if not self.exchange:
                raise APIException("Exchange not initialized")
                
            balance_info = self.exchange.fetch_balance()
            balance = float(balance_info.get('free', {}).get(currency, 0.0))
            logging.debug(f"üí∞ LIVE balance {currency}: {balance:.8f}")
            return balance
            
        except Exception as e:
            logging.error(f"Failed to get balance for {currency}: {e}")
            return 0.0

    def get_free_base(self, symbol: str) -> float:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞ –±–∞–∑–æ–≤–æ–π –≤–∞–ª—é—Ç—ã"""
        
        try:
            base_currency = symbol.split('/')[0]  # BTC –∏–∑ BTC/USDT
            return self.get_balance(base_currency)
        except Exception as e:
            logging.error(f"Failed to get free base for {symbol}: {e}")
            return 0.0

    def get_paper_balances(self) -> Dict[str, float]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –±–∞–ª–∞–Ω—Å–æ–≤ (—Ç–æ–ª—å–∫–æ –¥–ª—è SAFE MODE)"""
        if self.safe_mode:
            return dict(self._paper_balances)
        return {}

    def reset_paper_balances(self):
        """–°–±—Ä–æ—Å —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –±–∞–ª–∞–Ω—Å–æ–≤ –∫ –Ω–∞—á–∞–ª—å–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏—è–º"""
        if self.safe_mode:
            self._paper_balances = {
                "USDT": 10000.0,
                "BTC": 0.0,
                "ETH": 0.0,
            }
            logging.info("üîÑ Paper balances reset to default values")

    # ==================== MARKET INFO ====================

    def market_min_cost(self, symbol: str) -> float:
        """–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –æ—Ä–¥–µ—Ä–∞ –≤ USDT"""
        
        try:
            market_info = self._get_market_info(symbol)
            return float(market_info.get('limits', {}).get('cost', {}).get('min', 5.0))
        except Exception:
            return 5.0  # –î–µ—Ñ–æ–ª—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è Gate.io

    def market_min_amount(self, symbol: str) -> float:
        """–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –æ—Ä–¥–µ—Ä–∞"""
        
        try:
            market_info = self._get_market_info(symbol)
            return float(market_info.get('limits', {}).get('amount', {}).get('min', 0.00001))
        except Exception:
            return 0.00001  # –î–µ—Ñ–æ–ª—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ

    def round_amount(self, symbol: str, amount: float) -> float:
        """–û–∫—Ä—É–≥–ª–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–æ–≥–ª–∞—Å–Ω–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –±–∏—Ä–∂–∏"""
        
        try:
            market_info = self._get_market_info(symbol)
            precision = market_info.get('precision', {}).get('amount', 8)
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º Decimal –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è
            decimal_amount = Decimal(str(amount))
            rounded = decimal_amount.quantize(Decimal('0.1') ** precision, rounding=ROUND_DOWN)
            
            return float(rounded)
            
        except Exception as e:
            logging.error(f"Failed to round amount for {symbol}: {e}")
            return round(amount, 8)

    def round_price(self, symbol: str, price: float) -> float:
        """–û–∫—Ä—É–≥–ª–µ–Ω–∏–µ —Ü–µ–Ω—ã —Å–æ–≥–ª–∞—Å–Ω–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –±–∏—Ä–∂–∏"""
        
        try:
            market_info = self._get_market_info(symbol)
            precision = market_info.get('precision', {}).get('price', 6)
            
            return round(price, precision)
            
        except Exception as e:
            logging.error(f"Failed to round price for {symbol}: {e}")
            return round(price, 6)

    def _get_market_info(self, symbol: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ä—ã–Ω–∫–µ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        
        current_time = time.time()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        if (symbol in self._markets_cache and 
            current_time - self._cache_timestamp < self._cache_ttl):
            return self._markets_cache[symbol]
        
        try:
            if not self.exchange:
                # –î–µ—Ñ–æ–ª—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –µ—Å–ª–∏ –Ω–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
                market_info = {
                    'id': symbol,
                    'symbol': symbol,
                    'base': symbol.split('/')[0],
                    'quote': symbol.split('/')[1],
                    'active': True,
                    'type': 'spot',
                    'precision': {
                        'amount': 8,
                        'price': 6
                    },
                    'limits': {
                        'amount': {'min': 0.00001, 'max': 10000},
                        'price': {'min': 0.01, 'max': 1000000},
                        'cost': {'min': 5.0, 'max': 1000000}
                    }
                }
            else:
                markets = self.exchange.load_markets()
                market_info = markets.get(symbol, {})
                
                if not market_info:
                    raise APIException(f"Market {symbol} not found")
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
            self._markets_cache[symbol] = market_info
            self._cache_timestamp = current_time
            
            return market_info
            
        except Exception as e:
            logging.error(f"Failed to get market info for {symbol}: {e}")
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
            return {
                'precision': {'amount': 8, 'price': 6},
                'limits': {
                    'amount': {'min': 0.00001},
                    'cost': {'min': 5.0}
                }
            }

    # ==================== UTILITY METHODS ====================

    def get_trading_fees(self, symbol: str) -> Dict[str, float]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π"""
        
        try:
            if self.safe_mode:
                return {'maker': 0.002, 'taker': 0.002}  # 0.2% –¥–ª—è Gate.io
            
            if not self.exchange:
                raise APIException("Exchange not initialized")
                
            fees = self.exchange.fetch_trading_fees()
            symbol_fees = fees.get('trading', {}).get(symbol, {})
            
            return {
                'maker': float(symbol_fees.get('maker', 0.002)),
                'taker': float(symbol_fees.get('taker', 0.002))
            }
            
        except Exception as e:
            logging.error(f"Failed to get trading fees for {symbol}: {e}")
            return {'maker': 0.002, 'taker': 0.002}

    def check_connection(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –±–∏—Ä–∂–µ–π"""
        
        try:
            if not self.exchange:
                return False
                
            # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ –ø–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Å–µ—Ä–≤–µ—Ä–∞
            self.exchange.fetch_time()
            return True
            
        except Exception as e:
            logging.error(f"Connection check failed: {e}")
            return False

    def get_server_time(self) -> int:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Å–µ—Ä–≤–µ—Ä–∞"""
        
        try:
            if not self.exchange:
                return int(time.time() * 1000)
                
            return self.exchange.fetch_time()
            
        except Exception as e:
            logging.error(f"Failed to get server time: {e}")
            return int(time.time() * 1000)

    def get_trade_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Å–¥–µ–ª–æ–∫ –∏–∑ CSV"""
        
        try:
            if not os.path.exists(self.csv_file):
                return []
                
            with open(self.csv_file, mode="r", newline="", encoding="utf-8") as f:
                reader = csv.DictReader(f)
                trades = list(reader)
                
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ N —Å–¥–µ–ª–æ–∫
            return trades[-limit:] if trades else []
            
        except Exception as e:
            logging.error(f"Failed to read trade history: {e}")
            return []

    def get_status_summary(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞"""
        
        balances = {}
        try:
            if self.safe_mode:
                balances = self.get_paper_balances()
            else:
                # –ü–æ–ª—É—á–∞–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –±–∞–ª–∞–Ω—Å—ã
                for currency in ["USDT", "BTC", "ETH"]:
                    balances[currency] = self.get_balance(currency)
        except Exception:
            pass
            
        return {
            "mode": "SAFE" if self.safe_mode else "LIVE",
            "connected": self.check_connection(),
            "balances": balances,
            "csv_file": self.csv_file,
            "markets_cached": len(self._markets_cache),
            "last_cache_update": datetime.fromtimestamp(self._cache_timestamp).isoformat() if self._cache_timestamp else None
        }